Discards the arguments for parent call from stack. (-> [[IntermediateLanguage]])

Since stack frame is not pushed by [[op_frame]] and popped by [[op_return]] for tail calls, we need to remove old arguments with op_shift.

h1. format

<pre><code>["shift", <n_args>, <opecodes_next>]</code></pre>

* n_args
** number of arguments this tail call passes
* opecodes_next
** must be ["apply"]

h1. description

op_shift removes arguments for parent call from stack. Suppose the following code:

<pre><code>(define (foo x y)
  (bar "a" "b" "c"))
(foo "x" "y")</code></pre>

Before applying bar, op_shift ["shift", 3, ["apply"]] removes the following values. Note that first four elements will not be popped - that's why this operation is named "shift".

* 3 //stack top
* "a" // arguments for tail call (bar)
* "b"
* "c"
* 2   // will be removed  // arguments for parent call (foo)
* "x" // will be removed
* "y" // will be removed

Also note that stack frame is not pushed by [[op_frame]] for tail calls.

h1. example

program:
<pre><code>((lambda () (print 1))</code></pre>

Here (print 1) is a tail call.

compiled:
<pre><code>[frame
   [constant 0
   [argument
   [close 0  // make a closure, and
      [constant 1
      [argument
      [constant 1
      [argument
      [refer-global "print"
      [shift 1
      [apply]]]]]]]
      [apply]  // immediately invoke it
   -1]]]
[halt]]</code></pre>

Without tail call optimization, this program is compiled to:

<pre><code>[frame
   [constant 0
   [argument
   [close 0
      [frame  // push stack frame
         [constant 1
         [argument
         [constant 1
         [argument
         [refer-global "print"
         [apply]]]]]]
      [return]]  // pop stack frame
      [apply]
   -1]]]
[halt]]</code></pre>