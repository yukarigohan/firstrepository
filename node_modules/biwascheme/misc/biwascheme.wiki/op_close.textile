Creates closure object. (-> [[IntermediateLanguage]])

h1. format

<pre><code>["close", <n>, <body>, <opecodes_next>, <dotpos>]</code></pre>

TODO: &lt;opecodes_next> should be the last in consistency with other opecodes

h1. description

op_close creates closure object onto the 'a' register.

* n
** number of free variables (i.e. local variables defined outside) which this closure contains
** eg. (lambda (a) a) -> 0
** eg. (lamdba () (+ b c)) -> 2
* body
** opecodes (compiled closure body)
* dotpos
** (see below)

h2. closure object

Scheme closures are represented by JS arrays with its attribute 'closure_p' assigned to true.

<pre><code>[body, freevar1, freevar2, ..., dotpos]</code></pre>

* body
** closure body compiled into opecodes
* freevar
** value of the free variable
** If the free variable may be reassigned by set!, a box is stored instead of the direct value (see footnote)
* dotpos
** used for handling rest args
** (lambda args ...) -> 0
** (lambda (a . rest) ...) -> 1
** (lambda (a b . rest) ...) -> 2
** (lambda (a b c) ...) -> -1
** (lambda () ...) -> 0

h1. example

program:
<pre><code>(lambda () 1)</code></pre>

compiled:
<pre><code>[close 
  0
  [constant 1
    [return]]
  [halt]
  -1]</code></pre>

h2. example of reassigned freevars

Usually closure object contains actual values of the freevars:

<pre><code>(define (f a b)
  (lambda () a b))
(f 11 22)

-> [ ["refer-free", 0, ["refer-free", 1, ["return"]]], 11, 22, -1]</code></pre>

When the freevar may reassigned by set!, a box (JS array contains the actual value) is stored. It will be unboxed by [[op_indirect]] (see also: [[op_indirect]], [[op_box]])

<pre><code>(define (f a b)
  (set! a 99)
  (lambda () a b))
(f 11 22)

-> [ ["refer-free", 0, ["indirect", ["refer-free", 1, ["return"]]]], [99], 22, -1]</code></pre>