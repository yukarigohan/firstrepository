<h1>Intermediate Language</h1>

<p>BiwaScheme is an IL based Compiler-Interpreter.</p>

<p>Most of the opecodes are inherited from 3imp_pdf.</p>

<p>Registers:</p>

<ul>
<li>a [object] : temporary</li>
<li>x [opecodes] : opecodes to execute next</li>
<li>f [integer] : [TODO: denotes start position of free variables in the stack?]</li>
<li>c [closure] : closure object which is currently executed (set to [] in toplevel)
<ul><li>Closure object contains information about freevars (outer variables). When closure requires value of a free variable, it is retrieved from this register.</li>
<li>Used by [[op_refer_free]], [[op_assign_free]]</li></ul></li>
<li>s [integer] : denotes stack size (TODO: can we remove this by using ary.push()/ary.pop()?)</li>
</ul>

<h2>Opecodes</h2>

<ul>
<li>Stack manipulation
<ul><li><a href="#constant">constant</a> : Set value of 'a' register</li>
<li><a href="#argument">argument</a> : Push value of 'a' register onto stack</li></ul></li>
<li>Control structure
<ul><li><a href="#test">test</a> : Conditional execution</li>
<li><a href="#close">close</a> : Create Scheme closure</li>
<li><a href="#conti">conti</a> : Capture continuation</li>
<li><a href="#nuate">nuate</a> : Invoke continuation</li>
<li><a href="#halt">halt</a> : Terminate program execution</li></ul></li>
<li>Function call
<ul><li><a href="#frame">frame</a> : Push stack frame</li>
<li><a href="#apply">apply</a> : Invoke procedure (Scheme closure or JS function)</li>
<li><a href="#return">return</a> : Terminate execution of a procedure</li>
<li><a href="#shift">shift</a> : Quick stack frame discard for tail call optimization</li></ul></li>
<li>Variable reference/assignment
<ul><li><a href="#refer-local">refer-local</a></li>
<li><a href="#refer-free">refer-free</a></li>
<li><a href="#refer-global">refer-global</a></li>
<li><a href="#assign-global">assign-global</a></li>
<li><a href="#assign-local">assign-local</a></li>
<li><a href="#assign-free">assign-free</a></li>
<li><a href="#box">box</a> : Create a 'box' for variables which may be reassigned by set!</li>
<li><a href="#indirect">indirect</a> : Get the current value closed in a box</li></ul></li>
</ul>

<h3>constant</h3>

<p>is used to push a value on to the stack.</p>

<p>op_constant is often used with the [[op_argument]].</p>

<h4>example</h4>

<p>program:</p>

<pre><code>(display "hello")</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant "hello"
   [argument
   [constant 1
   [argument
   [refer-global "display"
   [apply]]]]]]
[halt]]</code></pre>

<h3>argument</h3>

<p><a name="argument" /></p>

<p>is used to push a value (typically an argument of function call) onto the stack.</p>

<h4>format</h4>

<pre><code>["argument", &lt;opecodes_next&gt;]
</code></pre>

<h4>registers</h4>

<ul>
<li>reads:
<ul><li>a: the value to push</li>
<li>s: old stack size</li></ul></li>
<li>writes:
<ul><li>x: next opecode</li>
<li>s: new stack size</li></ul></li>
</ul>

<h4>example</h4>

<p>program:</p>

<pre><code>(print "hi")
</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant "hi"
   [argument
   [constant 1
   [argument
   [refer-global "print"
   [apply]]]]]]
[halt]]
</code></pre>

<h3>test</h3>

<p>is used to stop the evaluation of the program.</p>

<h4>format</h4>

<pre><code>["test", <opecodes_then>, <opecodes_else>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>'()</code></pre>

<p>compiled:</p>

<pre><code>[constant 7
[test
   [constant 8
      [halt]]
   [constant 9
      [halt]]]]</code></pre>

<h3>close</h3>

<p>Creates closure object.</p>

<h4>format</h4>

<pre><code>["close", <n>, <body>, <opecodes_next>, <dotpos>]</code></pre>

<p>TODO: &lt;opecodes_next> should be the last in consistency with other opecodes</p>

<h4>description</h4>

<p>op_close creates closure object onto the 'a' register.</p>

<ul>
<li>n
<ul><li>number of free variables (i.e. local variables defined outside) which this closure contains</li>
<li>eg. (lambda (a) a) -> 0</li>
<li>eg. (lamdba () (+ b c)) -> 2</li></ul></li>
<li>body
<ul><li>opecodes (compiled closure body)</li></ul></li>
<li>dotpos
<ul><li>(see below)</li></ul></li>
</ul>

<p>h2. closure object</p>

<p>Scheme closures are represented by JS arrays with its attribute 'closure_p' assigned to true.</p>

<pre><code>[body, freevar1, freevar2, ..., dotpos]</code></pre>

<ul>
<li>body
<ul><li>closure body compiled into opecodes</li></ul></li>
<li>freevar
<ul><li>value of the free variable</li>
<li>If the free variable may be reassigned by set!, a box is stored instead of the direct value (see footnote)</li></ul></li>
<li>dotpos
<ul><li>used for handling rest args</li>
<li>(lambda args ...) -> 0</li>
<li>(lambda (a . rest) ...) -> 1</li>
<li>(lambda (a b . rest) ...) -> 2</li>
<li>(lambda (a b c) ...) -> -1</li>
<li>(lambda () ...) -> 0</li></ul></li>
</ul>

<h4>example</h4>

<p>program:</p>

<pre><code>(lambda () 1)</code></pre>

<p>compiled:</p>

<pre><code>[close 
  0
  [constant 1
    [return]]
  [halt]
  -1]</code></pre>

<p>h2. example of reassigned freevars</p>

<p>Usually closure object contains actual values of the freevars:</p>

<pre><code>(define (f a b)
  (lambda () a b))
(f 11 22)

-> [ ["refer-free", 0, ["refer-free", 1, ["return"]]], 11, 22, -1]</code></pre>

<p>When the freevar may reassigned by set!, a box (JS array contains the actual value) is stored. It will be unboxed by [[op_indirect]] (see also: [[op_indirect]], [[op_box]])</p>

<pre><code>(define (f a b)
  (set! a 99)
  (lambda () a b))
(f 11 22)

-> [ ["refer-free", 0, ["indirect", ["refer-free", 1, ["return"]]]], [99], 22, -1]</code></pre>

<h3>conti</h3>

<p>is used to capture the continuation.</p>

<p>The captured continuation is invoked by <a href="#nuate">nuate</a>.</p>

<h4>format</h4>

<pre><code>["conti", <FIXME>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>(call/cc func)</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [conti 0
   [argument
   [constant 1
   [argument
   [refer-global "func"
   [apply]]]]]]
[halt]]</code></pre>

<h3>nuate</h3>

<p>is used to invoke a continuation.</p>

<h4>format</h4>

<pre><code>["nuate", <saved_stack>, <opecodes_next>]</code></pre>

<h4>description</h4>

<p>op_nuate takes saved stack as an argument. When op_nuate is invoked, the interpreter stack is replaced by this saved stack.</p>

<p>op_nuate is never generated by Compiler. It is dynamically generated by Interpreter when processing op_conti.</p>

<h4>example</h4>

<p>program:</p>

<pre><code>(define cc (call/cc identity))
(cc)</code></pre>

<p>compiled:</p>

<pre><code>[refer-local 0
[nuate #<Object{stack,last_refer,call_stack,tco_counter}>
[return]]]
</code></pre>

<h3>halt</h3>

<p>halt is used to stop the evaluation of the program.</p>

<h4>example</h4>

<p>program:</p>

<pre><code>'()
</code></pre>

<p>compiled:</p>

<pre><code>[constant ()
  [halt]]
</code></pre>

<h3>frame</h3>

<p>Pushes stack frame.</p>

<p>op_frame must be called before applying a function, except when it is a tail call (see also: <a href="#shift">shift</a>.)</p>

<h4>format</h4>

<pre><code>["frame", <opecodes_next>, <opecodes_after>]</code></pre>

<ul>
<li>opecodes_after
<ul><li>opecodes executed after the new stack frame is popped from stack</li></ul></li>
</ul>

<h4>description</h4>

<p>op_frame pushes a frame (i.e. the following values) onto stack:</p>

<ul>
<li><opecodes_after> - opecodes to execute after new frame is popped //stack top</li>
<li>value of 'f' register - position of previous frame</li>
<li>value of 'c' register - the closure currently executed</li>
</ul>

<p>Usually this frame is popped by <a href="#return">return</a>.</p>

<p>op_frame is generated by:</p>

<ul>
<li>function calls (foo 1 2 3)</li>
<li>call/cc (call/cc func)</li>
</ul>

<h4>example</h4>

<p>program:</p>

<pre><code>(print 11)</code></pre>

<p>compiled:</p>

<pre><code>[frame        // op_frame
   [constant 11          // push arguments to stack           
   [argument
   [constant 1           // push number of arguments 
   [argument
   [refer-global "print" // load function to 'a' register
   [apply]]]]]]          // invoke function
[halt]]</code></pre>

<p>Note that op_frame itself does not touch 'f' register. Since function arguments are evaluated between op_frame and <a href="#apply">apply</a> and these evaluations must be done in the current frame, 'f' register is updated by <a href="#apply">apply</a>.</p>

<h3>apply</h3>

<p>Invokes Scheme closure, library function or JS function.</p>

<h4>format</h4>

<pre><code>["apply"]</code></pre>

<h4>description</h4>

<p>In contrast to other opecodes, op_apply takes no arguments. Instead it retrieves needed information from the stack.</p>

<p>Before calling op_apply, you must put these values onto stack:</p>

<ul>
<li>func: closure or function to apply</li>
<li>n_args: number of arguments</li>
<li>arg1: first argument</li>
<li>arg2: second argument</li>
<li>arg3: third argument</li>
<li>x // usually stack frame is already prepared by [[op_frame]]</li>
<li>f</li>
<li>c</li>
</ul>

<p>h2. applicable things</p>

<ul>
<li>Scheme closure
<ul><li>a JS array</li></ul></li>
<li>Library function (map, +, etc.)
<ul><li>a JS function which takes args(array) and intp(Interpreter) as arguments</li></ul></li>
</ul>

<p>Note that you cannot invoke pure JS functions directly. You can use js-call or js-invoke instead.</p>

<h4>example</h4>

<p>program:</p>

<pre><code>(+ 11 22)</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant 22  
   [argument          // push 22 (second argument) to stack
   [constant 11  
   [argument          // push 11 (first argument) to stack
   [constant 2   
   [argument          // push 2 (number of arguments) to stack
   [refer-global "+"  // load function '+' to 'a' register
   [apply]]]]]]]]     // invoke the function with arguments 11 and 22
[halt]]</code></pre>

<h3>return</h3>

<p>Pops stack frame.</p>

<p>op_return is generated by (lambda ...) and must be called as the last opecode of function execution.</p>

<h4>format</h4>

<pre><code>["return"]</code></pre>

<p>op_return does not have <opecodes_next> because it pops next opecodes from stack.</p>

<h4>description</h4>

<p>op_return pops the following values from stack:</p>

<ul>
<li>n [integer] : number of arguments passed to this function call</li>
<li>arg1</li>
<li>arg2</li>
<li>arg3</li>
<li>x [opecodes] // stack frame pushed by [[op_frame]]</li>
<li>f [integer]</li>
<li>c [closure]</li>
</ul>

<p>op_return also sets x, f, c to register 'x', 'f', 'c'.</p>

<h4>example</h4>

<p>program:</p>

<pre><code>((lambda () 11))</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant 0
   [argument
   [close 0
      [constant 11
      [return]]
      [apply]
   -1]]]
[halt]]</code></pre>

<h3>shift</h3>

<p>Discards the arguments for parent call from stack.</p>

<p>Since stack frame is not pushed by <a href="#frame">frame</a> and popped by <a href="#return">return</a> for tail calls, we need to remove old arguments with op_shift.</p>

<h4>format</h4>

<pre><code>["shift", <n_args>, <opecodes_next>]</code></pre>

<ul>
<li>n_args
<ul><li>number of arguments this tail call passes</li></ul></li>
<li>opecodes_next
<ul><li>must be ["apply"]</li></ul></li>
</ul>

<h4>description</h4>

<p>op_shift removes arguments for parent call from stack. Suppose the following code:</p>

<pre><code>(define (foo x y)
  (bar "a" "b" "c"))
(foo "x" "y")</code></pre>

<p>Before applying bar, op_shift ["shift", 3, ["apply"]] removes the following values. Note that first four elements will not be popped - that's why this operation is named "shift".</p>

<ul>
<li>3 //stack top</li>
<li>"a" // arguments for tail call (bar)</li>
<li>"b"</li>
<li>"c"</li>
<li>2   // will be removed  // arguments for parent call (foo)</li>
<li>"x" // will be removed</li>
<li>"y" // will be removed</li>
</ul>

<p>Also note that stack frame is not pushed by [[op_frame]] for tail calls.</p>

<h4>example</h4>

<p>program:</p>

<pre><code>((lambda () (print 1))</code></pre>

<p>Here (print 1) is a tail call.</p>

<p>compiled:</p>

<pre><code>[frame
   [constant 0
   [argument
   [close 0  // make a closure, and
      [constant 1
      [argument
      [constant 1
      [argument
      [refer-global "print"
      [shift 1
      [apply]]]]]]]
      [apply]  // immediately invoke it
   -1]]]
[halt]]</code></pre>

<p>Without tail call optimization, this program is compiled to:</p>

<pre><code>[frame
   [constant 0
   [argument
   [close 0
      [frame  // push stack frame
         [constant 1
         [argument
         [constant 1
         [argument
         [refer-global "print"
         [apply]]]]]]
      [return]]  // pop stack frame
      [apply]
   -1]]]
[halt]]</code></pre>

<h3>refer-local</h3>

<p>is used to load the value of a local variable.</p>

<h4>format</h4>

<pre><code>["refer-local", <variable_pos>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>(define a 99)</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant 7
   [argument
   [constant 1
   [argument
   [close 0
      [refer-local 0
         [return]]
      [apply]
      -1]]]]]
[halt]]</code></pre>

<h3>refer-free</h3>

<p>is used to load the value of a free variable.</p>

<h4>format</h4>

<pre><code>["refer-free", <variable_pos>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>(let ((a "a")(b "b"))
  (let ()
    a)</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant "a"
   [argument
   [constant "b"
   [argument
   [constant 2
   [argument
   [close 0
      [constant 0
      [argument
      [refer-local 1
      [argument
      [close 1
         [refer-free 0
         [return]]
         [shift 0
         [apply]]
      -1]]]]]
      [apply]
   -1]]]]]]]
halt]</code></pre>

<h3>refer-global</h3>

<p>is used to load the value of a certain global variable.</p>

<h4>example</h4>

<p>program:</p>

<pre><code>map</code></pre>

<p>compiled:</p>

<pre><code>[refer-global "map"
[halt]]</code></pre>

<h3>assign-global</h3>

<p>is used to assign a value to a global variable.</p>

<h4>format</h4>

<pre><code>["assign-global", <str_variable_name>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>(define a 99)</code></pre>

<p>compiled:</p>

<pre><code>[constant 99
[assign-global "a"
[halt]]]</code></pre>

<h3>assign-local</h3>

<p>is used to assign value to a variable.</p>

<h4>format</h4>

<pre><code>["assign-local", <FIXME>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>See example of [[op_indirect]].</p>

<h3>assign-free</h3>

<p>is used to assign a value to a free variable.</p>

<h4>format</h4>

<pre><code>["assign-free", <FIXME>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>(let ((a "a"))
  (let ()
    (set! a "aa")))</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant "a"
   [argument
   [constant 1
   [argument
   [close 0
      [box 0
      [constant 0
      [argument
      [refer-local 0
      [argument
      [close 1
         [constant "aa"
         [assign-free 0
         [return]]]
         [shift 0
         [apply]]
      -1]]]]]]
      [apply]
   -1]]]]]
halt]</code></pre>

<h3>box</h3>

<p>is used to make a box for a variable which may be reassigned by set!.</p>

<h4>format</h4>

<pre><code>["box", <FIXME>, <opecodes_next>]</code></pre>

<h4>example</h4>

<p>See example of [[op_indirect]].</p>

<h3>indirect</h3>

<p>is used to load the value of a variable which may reassigned by 'set!'.</p>

<h4>format</h4>

<pre><code>["indirect", <opecodes_next>]</code></pre>

<h4>example</h4>

<p>program:</p>

<pre><code>(let ((a "a"))
  (set! a "b")
  a)</code></pre>

<p>compiled:</p>

<pre><code>[frame
   [constant "a"
   [argument
   [constant 1
   [argument
   [close 0
      [box 0
      [constant "b"
      [assign-local 0
      [refer-local 0
      [indirect
      [return]]]]]]
      [apply]
   -1]]]]]
[halt]]</code></pre>
