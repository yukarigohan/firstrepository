;(load "./macrotic-sugar.scm") ;; load macro definitions
(define-macro (when test s1 . Larg)
  `(if ,test
       (begin ,s1 ,@Larg)
       #f))

(define-macro (do-while pred b1 . Larg)
  `(let loop ()
     (begin ,b1 ,@Larg)
     (when ,pred (loop))))


(define-macro (do b1 . Larg)
   (let ((lst (gensym)) ;; list
	 (rev-lst (gensym)) ;; reversed list
	 (pred (gensym)) ;; predicate
	 (q-while (gensym)) ;; MUST be (quote while)
	 (lst-instr (gensym))) ;; instructions to execute list

      `(let ((,lst (cons
		    (quote ,b1)
		    (quote ,Larg))) ;; list
	     (,rev-lst '()) ;; reversed list
	     (,pred '()) ;; predicate
	     (,q-while '()) ;; MUST be (quote while)
	     (,lst-instr '())) ;; instructions to execute list
	  
	  (if (< (length ,lst) 2)
	      "ERROR: too few arguments: must not be less than 2"
	      (begin
		 (set! ,rev-lst (reverse ,lst))
		 (set! ,pred (car ,rev-lst))
		 (set! ,q-while (car (cdr ,rev-lst)))
		 (if (not 
		      (or (equal? ,q-while (quote while))
			  (equal? ,q-while (quote WHILE))))
		     "ERROR: WHILE key-word not found"
		     (begin
			(set! ,lst-instr (reverse
					  (cdr 
					   (cdr ,rev-lst))))
			(let loop ()
			   (map eval ,lst-instr)
			   (if (eval ,pred) (loop))))))))))

(define (string-contains-pos str1 str2 pos)
  (cond ((< (string-length str1) (string-length str2)) #f)

	((string=? str2 
		   (substring str1 
			      0 
			      (string-length str2)))
	 pos)

	(else
	 (string-contains-pos
	  (substring str1 1 (string-length str1))
	  str2
	  (+ 1 pos)))))#;)

(define (string-contains str1 str2)
  (string-contains-pos str1 str2 0))

(define (String-Contains str1 str2)
  (let1 res (js-invoke str1 'indexOf str2)
    (if (= res -1) #f res)))

;; fetch the web file from server
;(define wp (http-request "ObservateursCodes.html"))
(define wp (js-eval "require('fs').readFileSync('ObservateursCodes.html', 'utf8')"))

;; find the table_observateurs id
(define str-to-find "table_observateurs")

;; find beginning of table
(define id-pos (String-Contains wp str-to-find))

;; get the table of observers
(define str-table-obs-to-end
  (substring wp
	     (+ id-pos (string-length str-to-find) 2)
	     (- (string-length wp) 1)))

;; find end of table
(set! str-to-find "</TABLE>")

(define table-end-pos (String-Contains str-table-obs-to-end str-to-find))


;; TABLE of observers
(define str-table 
  (substring
   str-table-obs-to-end
   0
   (- table-end-pos 1)))

;; the observers table and the end of file
(define str-table-remaining str-table)


(define observer-code "")

;; function to return position after end of string to find
(define (return-pos-after-end-of-string str str-to-find)
  (+
   (String-Contains str str-to-find)
   (string-length str-to-find)))

;; function to get the string between two others one
(define (get-string-between-strings str str-before str-after)
  (substring str
	     (return-pos-after-end-of-string str str-before)
	     (String-Contains str str-after)))

(define (return-remaining-string-after-string str str-to-find)
  (substring str
	     (return-pos-after-end-of-string str str-to-find)
	     (string-length str)))

(define (is-end-of-TABLE? str)
  (string=? "</TABLE>" 
	    (substring str
		       0
		       (string-length "</TABLE>"))))

(define ew #f) ;; end while

(print "before scanning of TABLE...")

;(write (%macroexpand

(define debug #t)

(do  
  ;; extract the observer code from TABLE DATA of TABLE ROW
  (set! observer-code
        (get-string-between-strings
         str-table-remaining
         "<TD DIR=LTR ALIGN=LEFT>"
         "</TD>"))
    
;  (begin
;    (print observer-code)
;    #;(foo))
    (if debug
	(begin
	  (print observer-code)
	  #;(newline)))
  
  ;; truncate the head of table to access the others observers the same way we already do it
  (set! str-table-remaining
	(return-remaining-string-after-string str-table-remaining
					      "</TR>"))

  while (not (< (string-length str-table-remaining) 20)))
;))

(print "after scanning of TABLE.")
