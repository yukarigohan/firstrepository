(define-syntax plus
  (lambda (x)
    (syntax-case x ()
      ((_ a b)
        (syntax (+ a b))))))

;(define-syntax orr
;  (lambda (x)
;    (syntax-case x ()
;      ((_ e1 e2)
;        (syntax (let ((t e1)) (if t t e2)))))))

;(define-syntax swap!
;  (lambda (x)
;    (syntax-case x ()
;      ((_ a b)
;       #'(let ((temp a)) (set! a b) (set! b a))))))

;(define-syntax foo
;  (lambda (x)
;    (syntax-case x ()
;      ((_ a b)
;       #'(list->string (list a b))))))
;(define (f list)
;  (foo (car list) (cdr list)))
;(f '(1 2 3))

;----
;(print (%macroexpand (let ((t #t)) (orr #f t))))

    ;(define (g) 8)
    ;(define (f) (g) (raise 7))
    ;(f)
    ;
    ;((lambda (x) (set! x 3) x) 4)


;    (call-with-values
;          (lambda () (let ((h (make-eq-hashtable))) 
;                       (hashtable-set! h 'foo 1) 
;                       (hashtable-set! h 'bar #(2 3)) 
;                       (hashtable-entries h))) 
;          list)

;          (let ((h (make-eq-hashtable))) 
;                       (hashtable-set! h 'foo 1) 
;                       (hashtable-set! h 'bar #(2 3)) 
;                       (hashtable-entries h)) 
;    ((case-lambda (() 0)))
;(define f (lambda x x))
;(print (f 1))

;(lambda (n) (if (= n 0) 1 2))

;    (define (fact n) (if (= n 0) 1 (* n (fact (- n 1)))))
;(fact 5)
;(define x 1)
;(define a 1)
;(define (x)
;  (define (y)
;    (define (z)
;      (define a 2)
;      a)
;    (z))
;  (y))
;(let1 result (x) 
;  (list result a)
;(define (x)
;  (define a 2)
;  a)
;    (begin (define a 1)) (print a)

;    (print
;    ((lambda () (define a 1) a))
;    )
;(define (f x)
;  (define a 1)
;  (+ a x))

;((lambda (x) (begin (set! x 3) (set! x 2) (+ 1 3) x)) 1)
;
;        (define a 1) (define b 2) 
;        (define (f) (define a 3) (define b 4) (list a b)) 
;        (let1 result (f) 
;          (list a b result))
;
;(begin (define a 1)) a
;    (define a 1) 
;        (list a ((lambda () (begin (define a 2)) a)))
