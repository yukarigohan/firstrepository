# syntax-rules

o 順番
  1. syntax-rules
  2. sytnax-case (ただしマクロ時計算は新規インタプリタで実行)
    - 2.2 Pause禁止、CallはOKということにすれば新規でなくていいかも？？

o メモ
  -- BindingはEnvに埋め込めるのでは

- syntax-rules
- define-syntax
  - トップレベルか、bodyに書くことができる
  - bodyはlet属、parameterize, guard, case-lambdaに出てくる
    あとdefine, define-values
    またトップレベルの(begin ...)にはdefineが書けるのでその中はbody
    ライブラリの場合はbegin(かcond-expand)にbodyがある

o Symbolをrichにする(同名のものを区別できるようにする)という方針で実装できないか？
  - 実際には同名かどうか区別するのがコストかかるので、全てに連番を
    振ることになると思うけど。
    - let等で名前が生成されるタイミングで連番をインクリメントする

o picrin
  - ~/rr_2016/picrin/contrib/20.r7rs/scheme/base.scm
    - picrinの低レベルマクロ(#`とか)で実装されている
    - compileという関数が#`を返す。本体はcompile-rules
    - compile -> compile-rules -> compile-rule -> template-representation

## 処理系

- picrin: syntax-rules ER 独自
- chibi-scheme: syntax-rules ER 独自
- foment: syntax-rules
- Gauche: syntax-rules

- Guile: syntax-case(psyntax)
- Sagittarius: syntax-case
  - ~/rr_2017/sagittarius-0.7.11/boot/lib/macro.scm
  - mark-substベースではなさそう？

## Guile

module/ice-9/psyntax.scmなのかなぁ？

    (define-structure (syntax-object expression wrap module))
    (define-structure (ribcage symnames marks labels))

define-structure自体もこのファイルで、syntax-caseを使って定義されている。
vectorを生成するみたい。

    (define-structure (ribcage symnames marks labels))
    - constructor: (make-ribcage symnames marks labels)
    - predicate: (ribcage? x)
    - acccess: (ribcage-symname x)
    - assign: (set-ribcage-symname! x v)

## 例

典型例１(swap)

  (define-syntax swap
    (syntax-rules ()
      ((_ a b) (let ((temp` a)) (set! a b) (set! b temp`))))) 
  (define (foo temp temp2)
    (swap temp temp2))

  ; (let ((temp` temp)) (set! temp temp2) (set! temp2 temp`))

典型例２(list)

  (define-syntax mac1
    (syntax-rules ()
      ((_ x y) (list` x y))))
  (define (foo list)
    (mac1 (car list) (cdr list)))

  ; (define (foo list)
  ;   (list` (car list) (cdr list))

マクロ展開により重複する例(destrucuring-bind)

  (define-syntax mac
    (syntax-rules ()
      ((_) (let ((temp 1)) (mac temp))
      ((_ x) (let ((temp` 2)) (cons temp` x))))))
  (mac)

  ; (let ((temp 1)) (mac temp))
  ; (let ((temp 1)) (let ((temp` 2)) (cons temp` temp)))

## BC

+ genVar(id): "#{id.name}.#{n}"のようなシンボルを返す
+ strip(x): xはexpr|SyntaxObject。SyntaxObjectを外す(syntax->datumの本体)
+ top-marked?(wrap): Wrap#isTopMarked
- identifier?(x)
+ self-evaluating?(x)
+ add-mark(mark, Expr x): SO.addMark
+ add-subst(id, label, Expr x): SO.addSubst
  + extend-wrap(wrap, x): addMark, addSubstに埋め込んだ
    - extend-wrap(wrap, so) -> new SO(so.expr, wrap + so.wrap)
    - extend-wrap(wrap, expr) -> new SO(expr, wrap)
+ join-wraps(w1, w2): Wrap#join
+ extend-env(label, binding, env): Env#extend(label, binding)
+ id-binding(id, r): Env#bindingOfId
+ id-label(id): SO#getLabel
+ wrap-marks(wrap): Wrap#marks
+ same-marks?(m1*, m2*): Mark.isSameMarks
+ label-binding(id, label, r): Env#get(label) TODO: getはnullを返すので注意
+ exp(x, r, mr)
+ exp-macro
+ exp-core
+ exp-exprs
+ exp-quote
+ exp-if
- exp-lambda
- exp-let
- exp-letrec-syntax
- syntax-pair? syntax-car syntax-cdr
+ exp-syntax
+ free-identifier=?: Syntax.isFreeIdentifierEqual
+ bound-identifier=?: Syntax.isBoundIdentifierEqual
+ datum->syntax: Syntax.datumToSyntax
. syntax->datum: SyntaxObject#strip
+ expand(x)

## TODO

- lambdaを複数対応させる
- 「あやしい」と書いた箇所があやしい

----
## 2017/03/10

###  19:47

ごちゃごちゃしてきたので memo/hygenic_macro.md に移行する。

## 2017/03/09

### 組み込み 21:09

INITIAL_ENV_ITEMSをどうするか。
これ自体は使って無くて、InitialEnvとInitialWrapが本体。
InitialEnvは label からBinding(type, value) のハッシュを持つ。
 (syntaxごとに一つのLabelを作る)

InitialWrapはmarkSubstsとして、Substの列をもつ。
 Substはsyntaxの名前、TopMark、ラベルをもつ。

というような構造をいつ作るか？

一つずつ追加していけばいいかも？

## 2017/03/08

###  13:38

(print (expand '(let ((t #t)) (orr #f t))))


### 再開 09:01

o コード
  o hygenic-macroブランチ
    -- 一段落したら、内容を整理してコミットし直す
o できたこと
  o orrとswap!の展開。
o やること
  - expandを処理系に組み込む
  - パターンマッチ部分の実装
  - 「t.0」とかだとそういう名前があったときに衝突しそう
o 次の目標
  - Scheme上でマクロを定義できるようにする

## 2017/02/02

### guile 20:59

### あー 18:21

    1. #<SO (let ((t #t)) (orr #f t)) ...m0>
    1. #<SO ((lambda (t{m1...m0}) (orr #f t){m1...m0}) #t{m1...m0} t{m1...m0}) m1...m0>

exposeによってm1...m0を内部に伝播させたあとは、それが外側に残ってるのがおかしいのかな？
つまりこうならないといけない？

    1. #<SO (let ((t #t)) (orr #f t)) ...m0>
    1. #<SO ((lambda (t{m1...m0}) (orr #f t){m1...m0}) #t{m1...m0} t{m1...m0}) >

そのあとm1を再度付けるから、こうなる？

    1. #<SO ((lambda (t{m1...m0}) (orr #f t){m1...m0}) #t{m1...m0} t{m1...m0}) m1>

いやでも、これだとlambdaという名前が未定義になってしまう？

    1. #<SO (let ((t #t)) (orr #f t)) ...m0>
    1. #<SO ((lambda{m1...m0} (t{m1...m0}) (orr #f t){m1...m0}) #t{m1...m0} t{m1...m0}) >
                    ~~~~~~~~このへんも付けないといけないのか？

(syntax (lambda (t) ...)) みたいにすると、「lambda」にもマークが付くってことなのかな。
ERマクロだと,(rename 'lambda) としないといけないところだもんな。

### うーんわからん 18:09

_expandMacroで2回addMarkすると思うけど、それなのにm2が残るというのがわからん。

Guileのやつを動かしてみるしかないかも？

### あ 17:24

letがmacroなのにexposeを使っていない。

あ、lambdaもexpose使わないとだめか？

    // TODO: support arity != 1
    //if(!(paramList instanceof Pair)) throw new Error("lambda:  ")
    var newVar = Syntax.genVar(paramList.car.name);
    var bodyExpr = bodyExprs[0];

    var label = new Label();
    var binding = new Binding("lexical", newVar);
    var newEnv = env.extend(label, binding);

    var newBodyExprs = bodyExprs.map(function(bodyExpr){
      var b =
        SyntaxObject.addSubst(new SyntaxObject(paramList.car, so.wrap),
                              label,
                              new SyntaxObject(bodyExpr, so.wrap));
      return Expander._exp(b, newEnv, metaEnv);
    });

    return List.apply(null, [Sym("lambda"), List(newVar)].concat(newBodyExprs));

### substが1つしかないのは 17:07

1. #<SO (swap! temp z) m1...m0>
1. #<SO (let ((temp temp{m1...m0})) (set! temp{m1...m0} z{m1...m0}) (set! z{m1...m0} temp)) m1...m0>

### あー 16:57

連結が逆？

    _expandCore #<SO (set! temp{m1...m0} z{m1...m0}) [temp(m2m1m0)l8]m2m1...m0>

このSOをexposeしたとき、いまは1番目が以下のようになっているが、

    _exp #<SO temp [temp(m2m1m0)l8]m2m1...m0m1...m0> 
 
                  m1...m0[temp(m2m1m0)l8]m2m1...m0  が正しいWrapなのではないか。

と思ったけどp.450見るとケツにつけるのが正しいっぽいなぁ。
  
### いやいいのか？ 16:50

orrのほうだと：

    _exp #<SO t [t(m3m2m1m0)l9]m3m2[t(m1m0)l8]m1...m0m2[t(m1m0)l8]m1...m0> 
                                                        ~~~~~~~~~ これが有効なのでl8になるっぽい。

ということは：

    _exp #<SO temp [temp(m2m1m0)l8]m2m1...m0m1...m0
                                           ~~ このへんにsubst[temp]がないのがおかしいのか？

orrの場合はlambdaによって[t(m1m0)l8]が付けられる。

### ふーむ 15:02

こうなってしまった。

  _exp #<SO temp [temp.0(m2 m1 m0)l7]m2m1...m0m1...m0>

m1...m0m1...m0みたいになっているのは明らかにおかしい。

ここで内側のtempやzにm1...m0が付いてるのがおかしい？

    #<SO (let ((temp temp{m1...m0})) (set! temp{m1...m0} z{m1...m0}) (set! z{m1...m0} temp)) m1...m0>

これはswap!マクロが生成してるのか。まあexposeしたらこうなるような気がする。

### 状況 14:53

- misplaced constantになる
  - _exp(#<SO #<SO temp m1>>) をしようとしているから。
  a) SOがネストしてるのがおかしい？
    - なぜネストするのか？
      - #<SO (set! #<SO temp m1> ...)> という式がある。
        これを単純にexposeするとSOSOになる。
        - syntax-carの定義から考えると、join-wrapsしないといけないのかも？
  b) SOがネストしている場合に対応しないといけない？
    - 

- (syntax-car x)
  = (extend-wrap x.wrap x.expr.car)
  = carがSOなら
    new SO(car.expr, join-wraps(x.wrap, car.wrap))
    carがSOでないなら
    new SO(car, x.wrap)

## 2017/01/31

### syntax 15:28

syntaxでパターン変数を埋め込むと、結果はSOを含んだSOになるのではないか？？という気がしてきた。

1.  ソース： (let ((t #t)) (or' #f t))
  - この時点ではpureなsexpである。
1. let-core
  - ラベルl1を生成。パターン変数bodyにadd-subst(l1, t)する
     <(or' #f t) [t, (), l1]>   環境 {l1: lexical(t.1)}
  - bodyがor'から始まるのでユーザマクロの展開が行われる(_expandMacro)
    - 新しいマークm2を生成。m2を付けたものをユーザマクロに渡し、結果に再度m2を付ける
1. or'
  - 入力は <(or' #f t) m2 [t()l1]> かな？
  - or'のパターンは(_ e1 e2)で、テンプレートは #'(let ((t e1)) (if t t e2))
   < (<let> ((<t> <#f m2 [t()l1]>))
     (<if> <t> <t> <t m2 [t()l1]>))
     m2>
  - これを見ると、e1, e2を参照した部分がSOになっている
    e1: <#f m2 [t()l1]>
    e2: <t m2 [t()l1]>
    - これはどうやって作るのか。syntax-cdrかな？
      (syntax-cdr <(or' #f t) m2 [t()l1]>)
      = (extend-wrap #<Wrap m2 [t()l1]> (#f t))
      = <(#f t) m2 [t()l1]>

### そろそろ動かしたい 15:06

letの例とかを動かしてみたい。

## 2017/01/27

### syntax-car 17:24

これがexposeに相当するのか。

  (syntax-car so)
  -> (extend-wrap so.wrap (car so.expr))

これって単に(make-syntax-object (car so.expr) so.wrap) じゃだめなのか？
extend-wrapすることに意味がある？

1 so.expr.carがSOであるケースを心配している？
  - annotation実装しなければ問題ない？
2 これによりマークをキャンセルするケースがある？
  つまり so.wrapの末尾マークとcar.wrapの先頭マークが同じ
  - と思ったけど1でないと2にはならないのか。

### BC 16:39

- (lambda (var) body)
  - label = make-label
    newVar = gen-var #'var
  - newBody = add-subst(#'var label #'body)
    newEnv = extend-env(label, make-binding(lexical new-var), r)
  - (lambda (<newVar>)
      (<exp newBody newEnv mr))

- (let ((var expr)) body)
  - label = make-label
    newVar = gen-var #'var
  - newBody = add-subst(#'var label #'body)
    newEnv = extend-env(label, make-binding(lexical new-var), r)
    newExpr = exp(#'expr r mr)  // exprを評価するときはvarは見えない
  - (let ((<newVar> <newExpr>))
      (<exp newBody newEnv mr))

- (letrec-syntax ((kwd expr)) body)
  - label = make-label
    // exprを展開して(syntax-rules () ...) 等を得る
    synExpr = exp(#'expr.add-subst(#'kwd, label), mr, mr)
    // それを実行して構文オブジェクトを得る
    synObj = eval(synExpr)
    binding = make-binding('macro, synObj))
  - exp(#'body.add-subst(#'kwd, label), 
        r.extend(label, binding),
        mr.extend(label, binding))

## 2017/01/24

### sais 11:13

### expose 11:13

  SO#< ('a . 'b) m2> を

  ( SO#<'a m2> . SO#<'b m2> ) にする操作がexposeなのだとしたら、

  exposeの結果は、SOを要素とするS式になる...か？

(syntax-case ()
  ((_ a b)


## 2017/01/23

### sais 20:19

4.2

- symbolic名とは別に「bounding name」という概念を導入し、同じ名前だけど
  違う意図を持った変数を指し分ける


### stripがSO以外を取るのはなぜか 16:11

つまり、なぜSO#exprにSOが入るのか。

- make-syntax-object
  - extend-wrap(wrap x): xはSOまたはexpr
    - add-subst
    - add-mark
  - expand(x): make-syntax-object(x, wrap)

うーん、これだけ見た限りではexprにSOが入ることはなさそうだが。

guileのソース見ると
                           (make-syntax-object
                            (decorate-source (syntax-object-expression x) s)
みたいなのがあるから、annotation入れたときに必要になるのかな？

### substは何のために使うか 11:33

- getLabelが、substを見てlabelを判断する
  例
    <t [t(m2)l2] m2>の場合、ラベルはl2
    <t [t(m2)l2] [t()l1]>の場合、ラベルはl1
- lambdaが、それぞれの引数についてsubstを付加する
  例
    - (lambda (t) ...):  bodyに[t()l1]を付ける
    - マクロがlambdaを生成したあと
      (lambda (t) ...):  bodyにマークm2が付いているので、[t(m2)l2]を付ける


biningOfId(id)したときに、

## 2017/01/21

### syntax-rules 22:48

  (define-syntax swap!
    (syntax-rules ()
      ((_ a b) 
        (let ((temp b)) (set! b a) (set! a temp)))))

syntax-rulesの場合は#'とかないからシンプルだな。
「b」は必ずパターン変数への参照とみなされる。

### expanderとsleep 22:46

BiwaSchemeではSchemeコードの評価が一般に1つのJS関数呼び出しで完結しないから、
syntax-caseを実装するにはexpanderをCPSで書かないといけないような気がしたけど、
マクロ展開時にCallを使ってはいけないというルールでもよい..., か？どうかな。

いやこれだとmapとかも呼べなくなるから強すぎるかぁ。


## 2017/01/20

### BC 20:19

マクロ：
  (define-syntax or'
    (lambda (x)
      (sytanx-case x ()
        ((_ e1 e2)
         #'(let ((t e1)) (if t t e2))))))

ソース：
  (let ((t #t)) (or' #f t))

subst = [id, (marks), label]

1. < (let ((t #t)) (or' #f t)) >
1. let-core
   <(or' #f t) [t, (), l1]>   環境 {l1: lexical(t.1)}
1. or': マークm2を生成
              | 内側のt
   < (<let> ((<t> <#f m2>))
     (<if> <t> <t> <t m2 [t, (), l1]>))
     m2>            | 外側のt
   ; パターン変数経由で持ってきた「外側のもの」に(アンチ)マークm2が付いている
   ; これにより、「or'マクロが生成したもの」だけm2が付いたことになる
1. SOを展開(expose)？
   (<let m2> ((<t m2> <#f m2>))
     <(<if> <t> <t> <t m2 [t, (), l1]>) m2>)
1. let-core
     <(<if> <t> <t> <t m2 [t, (), l1]>) [t, (m2), l2] m2>
     環境：{l1: lexical(t.1), l2: lexical(t.2)}
1. expose?
      (<if [t(m2)l2] m2>
        <t [t(m2)l2] m2>
        <t [t(m2)l2] m2>
        <t [t(m2)l2] m2 m2 [t()l1]>)  ; 
                     ~~~~~ここはキャンセルして無くなる
1. if-core
  1. cond節 <t [t(m2)l2] m2> 
    これのgetLabel(?)はl2を返す 名前tとマークm2がともに一致するため
    そのためbindingOfIdはラベルl2に対応するlexical(t.2)を返す
  1. then節：おなじ
  1. else節 <t [t(m2)l2] [t()l1]>
    マークm2がないので[t(m2)l2]は適用されない。
    [t()l1]の方は適用されるので、bindingOfIdはlexical(t.1)となる
  1. 結果としてこうなる
      (if t.2 t.2 t.1) 

    (let ((t.2 #f)) (if t.2 t.2 t.1))
  (let ((t.1 #t)) (let ((t.2 #f)) (if t.2 t.2 t.1)))

- exposeはいつ走るのか？
  > The functionality of expose is required only by syntax-case, which uses expose to destructure the input value as far as necessary to match against the input patterns.
  syntax-caseが、入力がパターンにマッチするかを調べるときに必要になる？

## 2017/01/17

### guile 23:51

## 2017/01/16

### psyntaxの方 21:33

こっちはsyntax-case-transformerがある

      (lambda (e r mr)
        (syntax-match e ()
          ((_ expr (keys ...) clauses ...)
           (begin
             (unless (for-all (lambda (x) (and (id? x) (not (ellipsis?  x)))) keys)
               (stx-error e "invalid literals"))
             (let ((x (gen-lexical 'tmp)))
               (let ((body (gen-syntax-case x keys clauses r mr)))
                 (build-application no-source
                   (build-lambda no-source (list x) body)
                   (list (chi-expr expr r mr)))))))))))

1. syntax-match

1. syntax (build-application ae fun-exp arg-exps)
       `(,fun-exp . ,arg-exps)
  つまり
    `(

### syntax-case自身は何を返すか？ 19:35

~/rr_2017/ChezScheme/s/syntax.ss:

  (global-extend 'core 'syntax-case
    (lambda (e r w ae)
      (define (clause y)
        (syntax-case y ()
          [(pattern template)
           #'(pattern #t template)]
          [(pattern fender template)
           #'(pattern fender template)]
          [_ (syntax-error y "invalid syntax-case clause")]))
      (let ([e (source-wrap e w ae)])
        (syntax-case e ()
          [(_ val (lit ...) cl ...)
           (if (andmap valid-literal? #'(lit ...))
               (let ([x (gen-var 'tmp)])
                 (build-let ae
                   (list x)
                   (list (chi #'val r empty-wrap))
                   (gen-syntax-case 'syntax-case x #'(lit ...)
                     (map clause #'(cl ...)) r)))
               (syntax-error e "invalid literals list in"))]))))

1. build-let
    (build-call ae (build-lambda #f x* body) e*)))
1. build-call
    (build-profile ae
      `(call ,(make-preinfo (ae->src ae) #f) ,e ,e* ...))))
1. build-profile
             (generate-profile-forms))
  または、
           `(seq (profile ,src) ,e)
  または、e

## 2017/01/14

### expose 23:58


## 2017/01/13

### psyntax:syntax-transformer 12:10

    (define core-macro-transformer
      ...
          ((syntax)                 syntax-transformer)

定義は以下

    (define syntax-transformer
      (let ()
        ; 内部define ...
        ; ...
        (lambda (e r mr)
          ; eはpsyntaxのstxオブジェクト
          (syntax-match e ()
            ((_ x)
             (let-values (((e maps)
                           (gen-syntax e x r '() ellipsis? #f)))
               (regen e)))))))

syntax-matchとは

  ;;; The syntax-match macro is almost like syntax-case macro.
  ;;; Except that:
  ;;;   The syntax objects matched are OUR stx objects, not
  ;;;     the host systems syntax objects (whatever they may be
  ;;;     we don't care).
  ;;;   The literals are matched against those in the system 
  ;;;     library (psyntax system $all).   -- see scheme-stx
  ;;;   The variables in the patters are bound to ordinary variables
  ;;;     not to special pattern variables.

### log 12:08

    ## Foment

    - syntax-rulesを見つけたときの処理(CompileSyntaxRules)
    - syntax-rulesで定義した構文を展開するときの処理(ExpandSyntaxRules)
      - 

    FEnvironment = (Name, HashMap, Interactive, Immutable)
    FLibrary = (Name, Exports)
    FSyntacticEnv = (GlobalBindings :: Environment/SyntacticEnv,
/                    LocalBindings :: List<Binding>)
    FBinding = (Identifier, Syntax, SyntacticEnv, RestArg,
                UseCount, SetCount, Escapes, Level, Slot, Constant)
    FIdentifier = (Symbol, Filename, SyntacticEnv, Wrapped, LineNumber, Magic)
    FReference = (Binding/Environment, Identifier)
    FPatternVariable = (RepeatDepth, Index, Variable)
    FPatternRepeat = (LeaveCount, Ellipsis, Variables, Pattern, Rest)
    FTemplateRepeat = (Ellipsis, RepeatCount, Variables, Template, Rest)

    ## コールグラフ

    - CompileSyntaxRules(FSyntacticEnv se, expr) -> FSyntaxRules
      - CopyLiterals
        - LiteralFind
      - CompileRule
        - CompilePatternVariables
          - PatternVariableFind, LiteralFind
        - AssignVariableIndexes
        - CompilePattern
          - PatternVariableFind, LiteralFind
          - CountPatternsAfterRepeat
          - RepeatPatternVariables
            - PatternVariableFind
        - CompileTemplate
          - PatternVariableFind
          - AddVarToTemplateRepeat
            - ListFind

## 2017/01/11

### ふたたび、Beautiful Code 13:31

- MarkとLabelは整数のようなもの
- SyntaxObject = (expr, wrap)
- Subst = (sym, marks, label)
- Binding = (type, value) typeはmacro/lexical/core

- genVar(id): "#{id.name}.#{n}"のようなシンボルを返す
- strip(x): xはexpr|SyntaxObject。SyntaxObjectを外す(syntax->datumの本体)
+ top-marked?(wrap): Wrap#isTopMarked
- identifier?(x)
- self-evaluating?(x)
+ add-mark(mark, Expr x): SO.addMark
- add-subst(id, label, Expr x): SO.addSubst
+ extend-wrap(wrap, x): addMark, addSubstに埋め込んだ
  - xが普通のexprの場合は、SyntaxObject(x, wrap)
  - xがSOの場合は、xにwrapをjoinした新しいSOを返す
+ join-wraps(w1, w2): Wrap#join
- extend-env(label, binding, env)
- id-binding(id, r)
- id-label(id)
+ wrap-marks(wrap): Wrap#marks
- same-marks?(m1*, m2*)
- label-binding(id, label, r)
- exp(x, r, mr)
- exp-macro
- exp-core
- exp-exprs
+ exp-quote
- exp-if
- exp-lambda
- exp-let
- exp-letrec-syntax
- syntax-pair? syntax-car syntax-cdr
+ exp-syntax
- free-identifier=?
- bound-identifier=?
- datum->syntax
- syntax->datum
+ expand(x)

### 4.4 11:31

  wrapped expression (expressions with pending subst or marks):
    <e, u, {m...}>
    e: expression
    u: 環境(Ident => Sym)
    m...: マーク

    substを足す = uにsubstを適用する？

    markを足す = m...にmarkを足すか、削除する
      同じことをu内のIdentにもおこなう必要がある

  - eはwrapped expressionであってはいけない
    - exposeを直すことでこの条件を達成できる

  - m...が複数になることはまれ(macro generating macroのときだけとか？？)

### sais 10:50

markの素朴な定義:
  mark(c, m) = c  # 定数
  mark(cons e1 e2, m) 
    = cons mark(e1, m) mark(e2, m)
つまり構造をトラバースする(ので遅い)

identifierは、sym, mark i sym, subst exp i sym のいずれか
  実装上は、<symname: s1, binname: s2, {m...}>のようにできる
  markは整数でよい
  - mark(i, m): i.marksにmを足す(ただし既にある場合は削る)
  - subst(i1, i2, s):
    i1とi2のbinnameとmarksが同じなら i1.binname = s
    そうでなければ何もしない
  - strip(i): i.symname
  - resolve(i): i.binname

例 (or2 e1 e2) -> (let ((t e1) (if t t e2)))

   (let ((if #f)) (or2 if t)) という式を考える
   これはまず以下のように変換される
     (<let, let, {}> ((<if, if, {}> #f))
       (<or2, or2, {}> <if, if, {}> <t, t, {}>))
   1. letが解釈される(組み込みのletしか存在しないため)
     - 今回はletはlambdaに変換されないものとする
     (let ((G1 #f))
       (<or2, or2, {}> <if, G1, {}> <t, t, {}>))
  ...

## 2017/01/08

### SAiS 22:49

4.1 
  Exp := Sym | Const | (Exp . Exp)
  Env は、SymからTransformerまたはVariableまたはSpecialへのマッピング
    'quoteと'lambdaのみSpecial

  expand :: (Exp, Env) -> ExpandedExp
  expand(e, r) = case parse(e, r)
    constant c  -> symbolic-data c 
    variable s  -> variable s 
    application e1, e2  -> application expand(e1, r),
                                       expand(e2, r) 
    symbolic-data e  -> symbolic-data e 
    function s, e  ->
      e2 = expand(e, r.merge(sはVariableである))
      function s, e2 
    macro-application s, e ->
      expand(r[s].call(e), r)

  parse :: (Exp, Env) -> ParsedExp

## 2017/01/03

### 1992 Syntactic abstraction in Scheme. 19:05

http://www.cs.indiana.edu/~dyb/pubs/LaSC-5-4-pp295-326-abstract.html

1. Introduction
2. related work
3. APIと例
4. アルゴリズム
  1. 伝統的なマクロのシステム
    - これだと名前が衝突するよ、という話
  2. substベースのマクロ
    - markとsubstが出て来る
    - identifier = <original name, binding name, {mark ...}>
  3. Capturing
    - datum->syntaxについて
  4. lazyなsubstベース
    - 効率を良くしたい
    - markを付けるとき、中身を全部辿って書き換えるのは大変
      - exposeを導入
        - exposeを使うのは、syntax-caseで入力を解析するときだけ
  5. ソースとオブジェクトのcorrelation
    - エラーメッセージのために、ソース位置を付加するなど
    - expand(source e a, r) == source expand(e,r) a
5. 結論

### 1992 Writing hygienic macros in Scheme with syntax-case. 19:05

http://www.cs.indiana.edu/~dyb/pubs/tr356-abstract.html

1. Introduction
2. 用語の定義
3. 例
4. 展開プロセスの概要

###  01:46

expandMacro = function(p, x) {
  var mark = new Mark();
  addMark(mark, p(addMark(mark, x)));
}

exp = function(x, r, mr) {
  if (SO(x)がidentifier なら) {
    var b = id-binding(SO(id)
  }
}

### Beautiful Code 01:46

ああー答えっぽいものがー。

## 2017/01/01

### http://docs.racket-lang.org/guide/stx-phases.html 00:57

- Racketの場合、マクロ展開時に使いたい関数はbegin-for-syntaxで
  明示しないといけないらしい
  - あるいは、require時にfor-syntaxと書く
- ああーlevel…、そんな話もあったな…、


## 2016/12/31

### 16.2.4 http://docs.racket-lang.org/guide/with-syntax.html 19:32

- gensym的なやつ：with-syntax + generate-temporaries

### 16.2.3 http://docs.racket-lang.org/guide/syntax-case.html 16:38

- define-syntaxはlambdaを受け取れる(syntax -> syntax)
- syntax-rulesの場合、
  入力はsyntax-eでdeconstructされる
  出力はdatum->syntaxでsyntaxに変換される
- syntax-caseのいいところの一つは、エラーメッセージを詳しくできること

- 

  (define-syntax (swap stx)
    (syntax-case stx ()
        [(swap x y)
             (if (and (identifier? #'x)

  これ#'xがsyntaxってことは、xはsymbolなんだろうか？？


### id=? 14:22

http://docs.racket-lang.org/guide/stx-obj.html

  (define x 1)
  (define y x) ; この場合、yはxと同じidentifierではない
               ; (新たなlocationが割り当てられるので)
               ; x -> [ ] -> 1
               ; y -> [ ] ->

  (define (f a) ...)  ; a -> [ ] ->
  (define b '(1 2))   ; b -> [ ] -> '(1 2) 
  (f b)
    
requireを使って束縛のエイリアスを作ることができる
  > (require (only-in racket/base [car also-car]))
  
  car      -> [] -> #<function car>
  also-car -> 

datum->syntaxはlexical contextを表すctx(identifier)を引数にとる
  = syntax-caseでは、lexical contextを持ち回ることができるっぽい



## 2016/12/30

### わかったこと 01:21

- マクロ展開時は、expanderにidentifierを渡さないといけない


## 2016/12/29

### gacuhe doc 23:29

http://practical-scheme.net/gauche/man/gauche-refj/makuro.html#g_t_30de_30af_30ed

こんなんあったのか。

- swap!の場合はgensymで回避できるが、listが外側で束縛されるようなケースは
  回避できない(＝マクロ作者としてできることが無い)
- 大事な2つの性質
  1. マクロが新しい束縛を導入するとき、それは(リネームされるなどして)
    既存のものと衝突しない。
    // 注：再帰マクロの場合、展開毎にリネームしないといけないので注意
  2. マクロが識別子の自由参照を行うとき、それはマクロ定義時のレキシカルな
    スコープで決まるものとする(展開側の状況に影響されない)。
- ローカルマクロ：let-syntaxや、let + define-syntaxなど
- ER
  > 大雑把なルールとして、マクロの出力に挿入する識別子はすべてrenameを通すことを 徹底すれば、衛生は保たれます。
  - renameっていうのがmisleadingなんだな。「これはこのコンテキストのシンボル
    なので衝突しないようにしてください」という依頼なんだな。
  - renameで包まないことで、「使用時のコンテキスト」のシンボルを提供できる
    (anaphoric ifとか)。
  - id=?は、リテラル(condでいうelseとか)に使う
    > つまり、マクロ定義時と同じ束縛を 参照している場合にのみ有効となります
    - (let ((else 1))
        (cond ((#t else)))) ;このelseは

    - (if (id=? (rename '=>) a) という記述からわかること：
      1. renameはシンボルをidentifierにしたものを返す。
      2. ERのformパラメータは、シンボルではなくidentifierが入っている。


### env-lookup 21:27

src/compile.scm

 ;; Internal API - used while macro expansion
 (define-cproc env-lookup (name module frames)
   (return (env-lookup-int name (SCM_MAKE_INT 1) ;; SYNTAX
                           (SCM_MODULE module) frames)))
  return env_lookup_int(name, 1, module, frames)
 
 ;; env-lookup-int :: Name, LookupAs, Module, [Frame] -> Var
 ;;         where Var = Lvar | Identifier | Macro

### free-identifier=? 19:39

src/libmod.scm

1. id1/id2のいずれかがidentifierでないときは#f
2. id1とid2がeq?なときは自明に#t
3. それ以外はid1, id2をdeep-compareする
  1. b1, b2をlookupする (Lvar, Identifier, Macroのいずれか)
  2. LvarまたはMacroの場合は、eq?で判定
  3. Identifierの場合は、bound-gloc g1, g2を取得
    - 両方bound-glocがあるとき
    - unboundでないものがあるとき
      - gt
    

lookupとは？

              name module                 frames
- (env-lookup id   (identifier-module id) (identifier-env id)))
  - src/compile.scm

### gauche 13:19

src/macro.c

- objects
  - Syntax
  - Macro
  - SyntaxPattern(pattern, vars, level, numFollowingItems)
  - SyntaxRules

- struct
  - PatternContext
    ScmObj name;                /* name of this macro (for error msg)*/
    ScmObj form;                /* form being compiled (for error msg) */
    ScmObj literals;            /* list of literal identifiers */
    ScmObj pvars;               /* list of (pvar . pvref) */
    ScmObj ellipsis;            /* symbol/idendifier/keyword for ellipsis */
    int pvcnt;                  /* counter of pattern variables */
    int maxlev;                 /* maximum level */
    ScmObj tvars;               /* list of identifies inserted in template */
    ScmModule *mod;             /* module where this macro is defined */
    ScmObj env;                 /* compiler env of this macro definition */



## 2016/12/27

### PatternVariableFind 02:04

  - tplがパターン変数を指すどうかを判断: PatternVariableFind(se, pvars, tpl)

どうやったら判断できるのか。
PatternVariableFindを見ると単にMatchReferenceを呼んでるだけな感じ。

        if (MatchReference(pvar->Variable, se, var))

seは何に使うのか。

    FObject be = ResolveIdentifier(se, expr);

### というのを念頭においてCompileTemplateを読む 00:32

うーん、pairかvectorかくらいしか見てないような…？

- シンボルを見つけたとき:
  - MakeIdentifierでIdentifierに昇格させる
  - tplがパターン変数を指すどうかを判断: PatternVariableFind(se, pvars, tpl)
    パターン変数なときはIdentifierではなくPatternVariableを返す
  - そうでないときはIdentifierにしたものをそのまま返す

  - tplがパターン変数を指すとき、
    - var->RepeatDepth > 0 かつ、
      trsが'() または AddVarToTemplateRepeat(var, trs)が0を返したとき、
      "missing <ellipsis> needed to repeat pattern variable in template"
      というエラーを出す
      - エラー内容からみて、((_ x ...) x) みたいな例かな？

まあともかくシンボルはIdentifierかPatternVariableになるっぽい。

### 疑問 00:29

SyntaxRulesオブジェクトを作成する際に、Template部分をプログラムとして
解析する必要があるのか、ないのか？

例えばswapの例だと、temp`のbindingはletによって導入されるのだな、というのを
理解してないといけないような気がするのだが。

  (define-syntax swap
    (syntax-rules ()
      ((_ a b) (let ((temp` a)) (set! a b) (set! b temp`))))) 

別の例としては、この展開先のaはパターン変数aを参照しているわけではない。

  (define-syntax swap
    (syntax-rules ()
      ((_ a) `(a))))

## 2016/12/26

### FSyntaxRules 15:08

    - FSyntaxRules
      - Literals :: List<Reference>
      - Rules :: List<SyntaxRule>
      - SyntacticEnv 

    - FSyntaxRule
      - NumVariables :: Fixnum
      - Variables :: List<FPatternVariable>
        - RepeatDepth :: Fixnum
        - Index :: Fixnum
        - Variable :: Reference
      - Pattern :: VectorとかPatternVariableとかReference(literal?)とか_とか
        - PatternRepeatのこともある
          - LeaveCount
          - Ellipsis
          - Variables
          - Pattern
          - Rest
      - Template :: VectorとかListとか
        - FTemplateRepeatを含むこともある
          - Ellipsis
          - RepeatCount
          - Variables
          - Template
          - Rest

Repeatとは？

  (define-syntax foo
    (syntax-rules ()
      ((_ x ... y) (cons (list x ...) y))))
  (write (foo 1 2 3 4))
  ;=> ((1 2 3) . 4)

### R7RS 3.1 14:19

- identifierは、type of syntaxか値を保存するlocationに対して名前を付ける
  - type of syntaxと結びつくidentifierはsyntactic keywordといい、
    そのsyntaxのtransformerとbindされているという
  - locationと結びつくidentifierはvariableといい、
    そのlocationとbindされているという。
    そのlocationiに保存されている値をvariableのvalueという
    (単に「variableがvalueにbindされている」ということもある)
  - プログラムのある箇所で見えている有効なbindingの一覧を、
    その箇所でのenvironmentという
- binding constructs: この2種類のbindingを生成するようなexpression
  - variable binding constructs: lambda, let属, do
- identifierがbindされるとき、そのbindingがvisibleであるregion(プログラムテキストの範囲)がある
  - このregionはconstructによって決まる(lambdaならそのlambdaの中、など)
  - identiferへのmentionは、そのidentiferのbindingを指す。
    複数ある場合は最も内側のものが優先。
    - そのようなbindingがない場合、global environmentから探す。
      そこにもない場合、unboundという。

### syntax-rulesの実装 00:54

一回、ちゃんと想像したほうがいい気がする。

1. syntax-rulesを見つけたとき：syntax-rulesオブジェクトを作る
  syntax-rulesオブジェクトは、(パターン, テンプレート)の列
  - パターンは_, literal, identifier(パターン変数),
    constant, ellipsis, リスト, ベクタ
    (注：リテラル欄に_があるときは_はリテラルとして扱う)
  - テンプレートはidentifier, constant, ellipsis, リスト, ベクタ
2. それの呼び出しを見つけたとき：
  1. マッチするパターンを見つける
  2. テンプレートの穴に実際の式を埋め込む

## 2016/12/25

### CopyLiterals 22:24

```
static FObject CopyLiterals(FObject se, FObject obj, FObject ellip)
{
    FObject lits = EmptyListObject;
    FObject form = obj;
    return form.map {|x| // xはIdentifierかSymbol
        // literal欄にellipsisが書かれていたらエラー
        raise if (MatchReference(ellip, se, x))

        // literal欄に重複があったらエラー
        if (ReferenceP(LiteralFind(se, lits, x)))
            Raise "syntax-rules", "duplicate literal", List(x, form));

        id = x;
        id = MakeIdentifier(id) if (SymbolP(id))

        lits = MakePair(MakeReference(ResolveIdentifier(se, id), id), lits);
        obj = Rest(obj);
    }
}
```

    LiteralFind(se, List<Reference> list, obj)
    - list内から、MatchReference(ref, se, obj)であるrefを見つける
  

    MatchReference(Reference ref, se, expr) synpass.cpp
      - exprはSymbolかIdentifier (であるときしか真にならない)
    1 exprがSymbolのとき：
      ref->Identifier->Symbol != expr なら偽を返す
      expr = MakeIdentifier(expr)
    2 exprがIdentifierでないとき、偽を返す
    3 ref->Identifier->Symbol != expr->Symbolなら偽を返す

    4 be = ResolveIdentifier(se, expr)とし、ref->Binding == beなら真を返す
    6 beがEnvironmentでないか、ref->BindingがEnvironmentでないとき偽を返す
      - Environmentでない＝SyntacticEnvかBindingということだっけ？
      beとref->BindingがいずれもEnvironmentなときは、
        EnvironmentGet(be, expr)と
        EnvironmentGet(ref->Binding, ref->Identifier) が一致すれば真を返す

    MakeIdentifier(sym)
    - return(MakeIdentifier(sym, NoValueObject, 0));
      FilenameとLineNumberが未定義なIdentifierを作って返す

    EnvironmentGet(env, symid) library.cpp
      1 symidはIdentifierかSymbol
        symidがIdentifierなら、symid = symid->Symbolとする
      2 gl = env->HashMap[symid] (なければ#f)
      3 glがGlobalであるとき、Unbox(gl->Box)を返す
        そうでないときはNoValueObject

### ということで 03:50

        lits = MakePair(MakeReference(ResolveIdentifier(se, id), id), lits);

- litsの各要素はReference
  Referenceは、idとBinding(or Environment or SyntacticEnv)をペアにしたもの
- Bindingはse.LocalBindingsから探す(なければGlobalBindings)

Referenceってなんなんだろう？idだけでは、特定できないのだろうか。

### ResolveIdentifier synpass.cpp 03:30

- se.LocalBindingsからidを探してBindingを返す。
  se.LocalBindingsに入ってないときはse.GlobalBindingsを返す。

```
ResolveIdentifier(SyntacticEnv se, Identifier id) -> Environment/SyntacticEnv
{
    loop {
        lb = se->LocalBindings; // lbはBindingのリスト。
        lbの要素bで、
            IdentifierEqualP(b->Identifier, id)
            なものがあればbを返す

        if (IdentifierP(id->Wrapped) == 0)
            break;

        se = id->SyntacticEnv;
        id = id->Wrapped;
    }
    // 見つからなかった
    return(se->GlobalBindings);
}
```

IdentifierEqualP synpass.cpp
Identifierの同値の定義。どうもWrappedの列が同じなら同値らしい？

```
bool IdentifierEqualP(Identifier id1, Identifier id2)
{
    // シンボルとして同じものであることが前提
    if (id1->Symbol != id2->Symbol)
        return false

    for (;;)
    {
        FAssert(id1->Symbol == id2->Symbol);

        if (id1->SyntacticEnv != id2->SyntacticEnv)
            return false

        if (IdentifierP(id1->Wrapped) == 0)
          return(IdentifierP(id2->Wrapped) == 0);

        id1 = id1->Wrapped;
        id2 = id2->Wrapped;
    }
}
```

### CopyLiterals 02:34

    // (<literal> ...)

    FObject lits = ReverseListModify(CopyLiterals(se, First(Rest(obj)), ellip));

CopyLiteralsはリテラルの指定をパースしてる模様。
ellipを渡しているのは、ellipsisがリテラル欄にあったらエラーにするため。

litsはリストで、その要素はReferenceらしい。

        MakeReference(ResolveIdentifier(se, id), id)

## 2016/12/20

### CompileSyntaxRules 18:48

これがseを取るんだよな。

ellipsisとliteralの処理に使ってるけど、これらは後回し。

ReverseListModifyは要するにreverse!か。

    return(MakeSyntaxRules(lits, ReverseListModify(nr), se));
    // リテラル、ルール一覧、SyntacticEnv

        nr = MakePair(CompileRule(se, form, lits, First(rules), ellip), nr);
                                 senv, 式全体, リテラル, (<pattern> <template>)、ellipsis

式全体が必要なのはなぜ？と思ったがエラーメッセージのためか。なるほど。

#### CompileRule

各ルールはFSyntaxRuleになる。pvarsはpattern variables, cpatはcompiled pattern, tplはtemplateかな。
それぞれCompilePatternVariables, CompilePattern, CompileTemplateという関数がある。

    return(MakeSyntaxRule(ListLength(pvars), pvars, cpat, tpl));

### foment 01:44

- FSyntaxRulesがSyntacticEnvを持っている
  - CompileSyntaxRulesがSyntacticEnvを引数にとる(MakeSyntaxRulesに渡す)


>       ellip = MakeReference(ResolveIdentifier(se, First(Rest(obj))), First(Rest(obj)));

これ気になるな...。ellipseって式が指定できたりはしないんだろ？
...と思ったけどsyntax-rulesがネストしたときとかを考えてるのかな。

  (import (scheme base))

  (define-syntax foo
    (syntax-rules ell ()  ; テンプレートにellが出てきたらそれはellipseの
                          ; 意味ですよ、と言っている。
      ((_) 
        (syntax-rules ell ()  ; なのでこのellは、外側のやつのellipseとして
                              ; 扱わないといけない
                              ; うーん、でも外側のやつ展開するときは
                              ; 内側のやつがsyntax-rulesだ！と意識はしない
                              ; よね？
          ((_) "foo.")))))
  (define-syntax bar
    (foo))
  (write (bar))

とりあえず置いておこう。

        ellip = R.EllipsisReference;

これの型だけ知りたい。
compile.cppにあった。

     R.EllipsisReference = MakeReference(R.Bedrock, MakeIdentifier(StringCToSymbol("...")));

R.Bedrockの定義はfoment.cppにある。

    FObject nam = List(StringCToSymbol("foment"), StringCToSymbol("bedrock"));
    R.Bedrock = MakeEnvironment(nam, FalseObject);

FEnvironmentはfoment.hppに。

```cpp
typedef struct
{
    FRecord Record;
    FObject Name;
    FObject HashMap;
    FObject Interactive;
    FObject Immutable;
} FEnvironment;
```

MakeReferenceはcompile.cppに。

    FObject MakeReference(FObject be, FObject id)

beはFBindingかFEnvironment、idはFIdentifierらしい。
Identifierという概念もよく分かってない。あ、定義を見ればいいのか。

### FIdentifier

```cpp
typedef struct
{
    FObject Symbol;
    FObject Filename;
    FObject SyntacticEnv;
    FObject Wrapped;
    int_t LineNumber;
    int_t Magic;
} FIdentifier;
```

なんと、FilenameとLineNumberを持ってるのか。ということは、ソースコードのある位置に書いてある識別子、がIdentifierなのだな。そしてIdentifier一つ一つがSyntacticEnvへの参照を持っているっぽい。MagicはMakeIdentifierを見ると連番を振ってるようだ。

MakeIdentifierは識別子の名前であるSymbolと、ファイル名、行番号を引数に取る。
SyntacticEnvとWrappedはNoValueObjectになっている。

    FObject MakeIdentifier(FObject sym, FObject fn, int_t ln)
      ...
      nid->SyntacticEnv = NoValueObject;
      nid->Wrapped = NoValueObject;

この下にWrapIdentifierという関数がある。これはIdentifierとSyntacticEnvを引数に取り、新しいIdentifierを返す。名前、ファイル名、行番号、Magicは元のものを引き継ぐ。Wrappedで元のものを覚えているようだ。

```cpp
FObject WrapIdentifier(FObject id, FObject se)
    ...
    nid->SyntacticEnv = se;
    nid->Wrapped = id;
```

WrapIdentifierを使っているのはsynrules.cppのExpandTemplateだけ。

### ExpandTemplate

ExpandTemplateは、ExpandSyntaxRulesが与えられた式にマッチするパターンを見つけたときに呼ばれる関数。

ExpandSyntaxRulesはSyntacticEnv(たぶん)を引数に取る。
MatchPatternもseを使っている。

        else if (MatchAnyObjectP(cpat))
            return(1);
        else if (ReferenceP(cpat))
            return(MatchReference(cpat, se, expr));

### FReference

compile.hpp:

```cpp
typedef struct
{
    FRecord Record;
    FObject Binding;
    FObject Identifier;
} FReference;
```

BindingとIdentifierの組がReferenceらしい。

compile.cpp:

```cpp
FObject MakeReference(FObject be, FObject id)
{
    FAssert(sizeof(FReference) == sizeof(ReferenceFieldsC) + sizeof(FRecord));
    FAssert(BindingP(be) || EnvironmentP(be));
    FAssert(IdentifierP(id));

    FReference * r = (FReference *) MakeRecord(R.ReferenceRecordType);
    r->Binding = be;
    r->Identifier = id;

    return(r);
}
```

Identifierと、BindingまたはEnvironmentを受け取ってReferenceを作る。`r->Binding`は実際にはEnvironmentのこともあるようだ。

### BindingとEnvironmentの違い

```cpp
...                         // MakeBinding(compile.cpp)での処理：
    FObject Identifier;     // id(引数)
    FObject Syntax;         // NoValueObject
    FObject SyntacticEnv;   // se(引数)
    FObject RestArg;        // ra(引数, #t or #f)

    FObject UseCount;       // 0
    FObject SetCount;       // 0
    FObject Escapes;        // #f
    FObject Level;          // 0
    FObject Slot;           // -1
    FObject Constant;       // NoValueObject
} FBinding;

...                         // MakeEnvironment(library.cpp)での処理：
    FObject Name;           // nam(引数、型不明。シンボルか？)
    FObject HashMap;        // MakeEqHashMap()
    FObject Interactive;    // ctv(引数、boolean)
    FObject Immutable;      // #f
} FEnvironment;
```

なんか全然違うな。

MakeBindingで検索するとsynpass.cppでだけ使われている。

### synpass.cpp

doやcondなどを、より基本的な構文(lambdaとか)に置き換える処理がここにある。staticでない関数は以下。

- FObject ResolveIdentifier(FObject se, FObject id)
- FObject SyntaxToDatum(FObject obj)
- int_t MatchReference(FObject ref, FObject se, FObject expr)
- FObject SPassDo(FObject enc, FObject se, FObject expr)
- FObject SPassLambda(FObject enc, FObject se, FObject name, FObject formals, FObject body)
- FObject ExpandExpression(FObject enc, FObject se, FObject expr)
- static int_t EvaluateFeatureRequirement(FObject se, FObject expr, FObject cls, FObject obj)
- FObject CondExpand(FObject se, FObject expr, FObject clst)
- FObject ReadInclude(FObject op, FObject lst, int_t cif)

SPassLambdaはcompile.cppのCompileLambdaから呼ばれている。

```cpp
FObject CompileLambda(FObject env, FObject name, FObject formals, FObject body)
{
    FObject obj = SPassLambda(NoValueObject, MakeSyntacticEnv(env), name, formals, body);
    FAssert(LambdaP(obj));

    UPassLambda(AsLambda(obj), 1);
    CPassLambda(AsLambda(obj));
    APassLambda(0, AsLambda(obj));
    return(GPassLambda(AsLambda(obj)));
}
```

UPass, CPass, APassって何だ...。

### midpass.cpp

UPassLambda, CPassLambda, APassLambdaはmidpass.cppにあった。

AnalysisPassSymbolという名前があるからAはAnalysisかなあ。

UpassについてはFBindingを扱っている箇所があるからいずれ見ることになるかも？

### MatchPattern

## 2016/12/11

### 重複展開？ 00:31

  (syntax-rules ()
    ((_ (a . b) value body ...)
     (let ((e value))
       (destructuring-bind a (car e)
         (destructuring-bind b (cdr e)
           body ...))))

   (destructuring-bind ((x y) . z) '((1 2) 3 4 5) ...
=> (let ((e '((1 2) 3 4 5)))
     (destructuring-bind (x y) (car e)
     (destructuring-bind z (cdr e)
     ...
=> (let ((e '((1 2) 3 4 5)))
     (destructuring-bind (x y) (car e)
     (let ((z (cdr e)))
       ...
=> (let ((e '((1 2) 3 4 5)))
     (let ((e2 (car e)))
       (destructuring-bind x (car e2))
       (destructuring-bind y (cdr e2))
         (let ((z (cdr e)))
           ...
=> (let ((e '((1 2) 3 4 5)))
     (let ((e2 (car e)))
       (destructuring-bind x (car e2))
       (let ((y (cdr e2)))
         (let ((z (cdr e)))
           ...
=> (let ((e '((1 2) 3 4 5)))
     (let ((e2 (car e)))
       (let ((x (car e2))) 
         (let ((y (cdr e2)))
           (let ((z (cdr e)))  ; こいつが外側のeを参照しているので、
             ...               ; e2がeという名前だとまずい



## 2016/12/10

### ライブラリ 20:44

(define-library (example grid)
  (export make rows cols ref each
          (rename put! set!))
  (import scheme base)
  (begin
    (define (make n m) ...)
    (define (put! grid n m v) ...)
    (define n 1)
    (define (foo)
      n)  ; ライブラリのnを返す
    (define-syntax

(import (scheme base)
        (rename (prefix (example grid) grid-)))
(grid-make 24 24)

ライブラリかつinternal defineってことはあるか？
いや、(let ... (define-syntax はletローカルな定義だからexportされることはないのか。

###  20:37

compiler.jsを読み直している。

変数名の解決はコンパイル時に行われるのだ、ということを思い出した。
つまりIRには変数の名前が入っていない。すべて「3番目の自由変数を取り出す」みたいな形になっている(グローバル変数は除く)。

### 結局のところ 02:32

  (let ((a 1))
    ...
    (let ((a 2))
      ...
      ; ふつうはここでaと書いたら後者のaのことだけど、
      ; マクロによって前者のaがキャプチャされる可能性があり、
      ; その場合はマクロ展開後のコードから前者のaが見えないといけない。ということ

## 2016/12/09

### let 23:00

letとかguardの中にdefine-syntaxが書ける。

    (import (scheme base) (scheme write))

    (define foo 1)
    (define bar 1)
    (let ((baz 1))
      (define-syntax m1
        (syntax-rules ()
          ((_) (list foo bar baz))))

      (set! foo 2)
      (let ((bar 2) (baz 2))
        (write (m1))))

うーむ。

### condの話 20:57

r7rs.pdf p.24

(cond ((= x 1) => foo)) みたいな記法があるのか。関数適用するやつだっけ。

letはlambda、named letはletrecに変換されると。

それで：

  (let ((=> #f))
    (cond (#t => 'ok)))  ;=> ok

予約語をわざと束縛してもcondが壊れない、という例。ふむ。

### マークを付けるのだ 20:27

  (define-syntax swap!
    (syntax-rules ()
      ((_ a b)
       (let ((temp a))
         (set! a b)
         (set! b temp)))))

こうだよね。で、マークは

  (define-syntax swap!
    (syntax-rules ()
      ((_ a b)
       (<let> ((<temp> a))
         (<set!> a b)
         (<set!> b <temp>)))))

こうなる。
- bodyを歩く
  - a, bのように束縛されているもの(パターン変数)は、埋め込み先になるので
    何もしない
  - それ以外のシンボルは、
    - ライブラリで定義されているものだったらライブラリのシンボルというマークを付ける
    - そうでなければトップレベルのシンボルというマークを付ける

これで構文オブジェクトができた。

#### 展開時

  (swap! x y)

1. 構文オブジェクトから、マッチするパターンを探す
2. パターンのbodyに、xとyを埋め込む
  これで展開後のコードが得られる
  ただしシンボルにはマークが付いている(純粋なS式(?)ではない)
3. (展開結果にマクロがあれば再度展開する)
4. 展開するものがなくなったら展開終了なので、評価を続ける
  評価器はidentifierに対応してないといけない



### dest-bind.scm 20:15

goshだと動かないのかと思ってたけど動くな。直したとか？
てか逆にpicrinだと動かない。うーん。

###  03:13

ブクマしたけど、本当はマクロ展開ごとに別の名前を付けないといけない、という話がある。

## 2016/12/06

### gaucheのモジュール 22:27

> モジュールは、シンボルを束縛へとマップするオブジェクトで、 グローバル変数の解決に影響を与えます。

シンボルを束縛へとマップする、の意味がわかってきたかも。


    (define-module A
      (export foo)
      (define-syntax foo
        (syntax-rules ()
          ((foo x)
           (+ x 1)))))

    (import A)
    (define a 1)
    (print (%macroexpand (foo a)))

とすると、(#<identifier A#+> a 1) となった。+はモジュールAから探す、ということだね。

ところでこれって、マクロ展開結果をマクロに渡すときに困らないのかな？
いや、barがマクロだとそもそもfooが展開されないのか。
    (bar (foo 2))


### syntax-rules 21:45

どれにどんなマークを付ければよいのか？

    (define-syntax m1
      (syntax-rules ()
        ((_ x y)
         (let ((temp x))
           y))))

    (m1 a b)

    => (<let> ((<temp> a))
         b)

「あっち」と「こっち」の2種類でいいのかな。

ライブラリがある場合は？

### env 21:35

  (define z 1)

  (define (f x)
    (let ((y 1)
      ....


探索順序
1. ローカル変数 y
1. 外側のローカル変数
1. 関数の引数 x
1. グローバル変数z
1. 組み込みのもの(carとか+とか)

###  03:12

hygenicとは？

1. マクロ内で定義した名前が外とかぶってしまうケース
  (define-syntax ....
    (let ((temp 1)) ....   ; 外でtempという名前を使ってても大丈夫にしたい

2. マクロ内で使っている名前が外で上書きされているケース
  (define-syntax ....
    (list 1 2 3) ....      ; 外でlistが引数名だったりしても大丈夫にしたい

1はgensymで回避できるけど、2はそうではない。

## 2016/10/10

###  19:43

### うーん 02:56

http://community.schemewiki.org/?hygiene-versus-gensym

gensymの話しなくていい気がする。

- 単純な展開ではいくつかの問題がある
  - 名前の衝突
  - パッケージプライベートな名前を読んだ時
- すべての名前について、「衝突を回避する」か、穴を開ける(展開後の名前とする)
  かを判断する必要がある
  - そうすれば、意図しない衝突は無くなる(hygenic)

  - syntax-rules: すべて隠す
  - implicit-renaming: デフォルトで隠す、穴を開ける部分だけ明示
  - explicit-renaming: デフォルトで束縛、隠す部分だけ明示
  - syntax-case: 知らない

  - いずれにしろ、それぞれの名前がどの場所のを指しているのか、を管理する必要がある(= syntactic closure)

- CLの場合
  - Lisp-2なので衝突するケースが少ない
  - シンボルがパッケージに紐づく

### 書きかけ 02:00

---
http://community.schemewiki.org/?hygiene-versus-gensym

hygieneはgensymより強いんだ、ということが書いてある。まずマクロ定義における名前衝突の例としてswapというマクロを考える。

```scm
; 展開前
(swap x y)

; 展開後
(let ((temp x))
  (set! x y)
  (set! y temp))
```

こういうものをdefine-macro等で単純に定義すると、`(swap temp temp2)`みたいなコードを書いたときにtempという名前が衝突して望まない結果が得られる。gensymがあるシステムではgensymを使ってtempを「何とも重複しない名前」にすることで、これに対処できる。

一方でsyntax-rulesやsyntax-caseにはhygienicという「全自動名前衝突回避機能」のようなものが備わっており、gensymのようなものを書かなくても自動で衝突が回避される。

というところまでが前提知識で、これだけ読むと「なるほどhygienicマクロだとgensym書かなくていいから楽なんだな」という感じだけど、そもそも衝突が予期できないケースもあるよね、という話が続く。

## 予期しない衝突

たとえば「list」という名前が衝突することを考えよう。Schemeにはlistという組み込み関数があるのだが、Schemeでは変数と関数の名前空間は分かれていないので、ユーザがリストを受け取る引数にlistという名前を付けてしまうこともあるかもしれない。

このような場合に起こる悲劇が以下で、マクロ定義内ではlistは組み込み関数のつもりで使っているのだけど、それを展開するとlistが引数名の方に解決されてしまって誤動作が起こる。

```scm
; マクロ定義側
(define-macro (foo x y)
  ... (list 1 2) ...)

; マクロを使う関数 (展開前)
(define (bar list)
  ... (foo 3 4) ...)

; マクロを使う関数 (展開後)
(define (bar list)
  ... ...(list 1 2 )... ...)
```

## hygenicなマクロ

syntax-rulesやsyntax-caseのようなhygenic macroでは上記の問題が解決されており、listは展開後も組み込み関数を指す。つまりhygenic macroは単にgensymの手間が省けるというだけではなくて、「そもそも衝突するとは思わなかった名前」についても衝突が回避されるという点で

(Note: Common Lispで上記の問題がどのように解決されるかは筆者は知らないし、本記事の対象ではない。少なくともlistの例に関しては、CLでは変数と関数の名前空間が分かれているので衝突しない)
---

###  01:23

http://community.schemewiki.org/?hygiene-versus-gensym

make-promiseの例。マクロがモジュールローカルな識別子を使う場合、
単純な展開では困るという話。


## 2016/10/09

### syntactic closureとは 21:41

listの例を再掲。

  (define-macro (some-macro x y)
    (... (list x y) ...))  ; 何も問題なさそうだけど...
       
  (define (foo list)
    (some-macro x y)   ;=> ここでマクロを使うとマクロ内の(list x y)が誤動作する
    ...)

- 普通のclosure：「名前とvalueとの結びつき」をencloseしている
- syntactic closure：「名前とsyntaxとの結びつき」をencloseしている

ということでいいかな？

## 2016/07/04

### syntax-caseでsyntax-rules 14:36

http://www.katch.ne.jp/~leque/translations/srfi-72/srfi-72j.html

syntax-rulesは同等なsyntax-caseにわりと手短に変換できるっぽい。

(define-syntax syntax-rules
  (lambda (x)
    (syntax-case x ()
      ((_ (i ...) ((keyword . pattern) template) ...)
       (syntax (lambda (x)
                 (syntax-case x (i ...)
                   ((dummy . pattern) (syntax template))
                   ...))))))) 

変換前
(syntax-rules (i ...)
  ((keyword . pattern)
   template)
  ...)

変換後
(syntax-case x (i ...)
  ((dummy . pattern)
   (syntax template))
  ...)

あー、body部分にsyntax付けるだけ、っていうことなのね。

### syntax-rulesでlet-in-order 14:06

「束縛が被っちゃう」の意味がよく分からなくなってきた。
http://wasabiz.hatenablog.com/entry/2014/09/28/145739
ナイーブにやると、ということ？
マクロ展開ごとに@以降を別のものにすれば解決するだけの話？

## 2016/07/02

### http://www.katch.ne.jp/~leque/translations/srfi-72/srfi-72j.html 23:33

  srfi-72

- let-in-order
  再帰的にtを導入したときに互いにぶつかると困る、という話？

  destructual-bindの件と同じ話かな？

### https://twitter.com/anohana/status/433362108357427202 23:17

> @wasabiz 健全マクロの考え方のひとつは「一回のマクロ展開ごとに、その展開で挿入されたシンボルに新たなマークをつける」というものです。マクロ定義時と展開時の環境だけを見ていると、同じ環境で複数回展開されるときにはまります。Gaucheも実は同じ問題があります。(続)
> @wasabiz (承前)環境を考慮するとこのマークはひとつではなく複数になり得るとか、ルックアップ時のマークの考慮の仕方とかがややトリッキーなんですが、わかりやすい論文があったと思います。今ちょっと見つからないので見つけたらまた。
> @wasabiz Clingerの"Macros that work"だと思い込んでいたのですが確かめたら違いました。ずっと昔に紙に印刷して持ってたのを、どうせオンラインで見れるだろうと処分したんですが、さて見つからない…

「同じ環境で複数回展開される」ってどういうときだろう。



### http://wasabiz.hatenablog.com/entry/20120331/1333209310 22:43

  2012-03-31 syntactic closureは内部でどのように実装されているのか 

- define-syntaxはtransformerを受け取る
  transformerは、(lambda (expr use-env mac-env) ...) のような手続き
  を、mac-envでevalしたもの
  (TODO: どういうときに違いが出る？
   マクロ時計算みたいな話？
   evalはどのタイミングで行う？マクロ定義時かなぁ。)

- make-syntactic-closureはfree-env, free-vars, exprから、
  それらを構造体にしたものを作る

- 通常のclosureは、S式(lambda ...)に環境をくっつけたもの
  - syntactic closureもこれとほぼおなじ(S式＋環境)で、
    環境を引数で指定できるだけ

- free-varsはinjectするときに使う用(injectする識別子の列)

- SCがある環境では、evalの定義にSCが出てくる？
  - 式の評価結果がSCだった場合、指定された環境下で指定された式を評価する
  - 変数参照にも手を入れる必要がある
    - freevarに含まれる(=inject対象の)シンボルのときは、
      envではなくfreevar-envから引くってことかな？
- 「実はfreevarを使わなくても健全性を破壊することができます」
  (しかし方法は書いてない)

### Chibi 22:29

- syntax-rulesはERで実装されている(lib/init-7.scm)
  - literalがない場合
    (syntax-rules () ....)
    = (syntax-rules-transformer (syntax-rules () ....) rename compare)
  - literalがある場合
    (syntax-rules (a b) ....)
    = (let (((a b) #t)) ;???
        (syntax-rules/aux (syntax-rules (a b) ....)))

- er-macro-transformerもlib/init-7.scmで定義されている
  - make-syntactic-closureを使っている

ということは、ERを通さずに、SCでsyntax-rulesを実装することも
できるんだよね、多分。

### 現在のpicrin 22:19

  https://github.com/picrin-scheme/picrin/blob/master/contrib/10.macro/macro.scm

- SC (make-syntactic-closure)はprimitiveではない
  - make-ephemeron, make-identifierというのがprimitiveか？

- syntax-rulesは contrib/20.r7rs/scheme/base.scm にある。
  call-with-current-environment, make-ephemeron, make-identifier
  を使ってるっぽい

### http://wasabiz.hatenablog.com/entry/2014/09/28/145739 22:06 

  2014-09-28 健全なマクロは壊れている 

- 「低レベル健全マクロ」にはSC派とER派がある
  以下の問題はSC, ERに共通するもの
- ER
  - renameはシンボルを(マクロ定義側の)識別子に変換する手続き
    - set!やletをrenameすることで衝突を防ぐ
    - しかしswapにおけるtmpはどうだろうか？
      - (let ((#<identifier tmp>) a)
        みたいになるのが気持ち悪い(?)
  - 案１
    - "束縛の導入のシンボルと変数参照のシンボルを両方ともマクロ展開時に識別子へと持ち上げる"

    - 単純にやると、let-in-order http://www.katch.ne.jp/~leque/translations/srfi-72/srfi-72j.html
      みたいに新しい識別子を再帰的に導入した
      ときに衝突してしまう
      (同じ環境、同じ名前だからかぁ。)

  - 案２
    - シンボルをCLのuninterned symbol相当(?)と考える
      > 新しい束縛を導入する際の処理と健全性の確保の処理をそれぞれmake-fresh-symbolと
        renameに完全に分離したということになります。
    - この案ではinjectは諦めるらしい
      - (この案でinjectができないのはなぜ？)
      - 普通の3ERでは生のシンボルはinjectになる、んだよね

## 2016/07/02

### http://community.schemewiki.org/?syntactic-closures 19:05

- SCベースのマクロトランスフォーマ
  - aifのような例において、「基本は向こうの環境の名前を引くが、`it`だけは
    こっち(マクロ定義内)のitを指してほしい」みたいな指定ができる。
  - しかも式単位で指定できるので、aifのthen節でだけitが見えるみたいなことが簡単に書ける。

   (define-syntax aif 
     (sc-macro-transformer 
      (lambda (form environment) 
        (let ((condition  
               (make-syntactic-closure environment '() (cadr form))) 
              (consequent  
               (make-syntactic-closure environment '(IT) (caddr form))) 
              (alternative 
               (make-syntactic-closure environment '() (cadddr form)))) 
          `(LET ((IT ,condition)) 
             (IF IT 
                 ,consequent 
                 ,alternative))))))

- SCとER, IR, syntax-rulesの関係とは？
  - 「指定したやつだけinjectされる」という意味で、SCはIRに近い？

## 2016/06/30

### http://community.schemewiki.org/?hygiene-versus-gensym

hygieneはgensymより強いんだ、という話。ふむ

  (swap! x y)
    ↓
  (let ((temp x))
    (set! x y)
    (set! y temp))

define-macro + gensymがあれば、tempの衝突回避はできる。
しかしletやset!が上書きされるとやっぱり誤動作するよね？という話だった。

これはさすがに人工的すぎるけど、(SchemeはLISP-1なので)
listという名前の変数を定義してしまうことはわりとありそう。

  (define-macro (some-macro x y)
    (... (list x y) ...))  ; 何も問題なさそうだけど...
       
  (define (foo list)
    (some-macro x y)   ;=> ここでマクロを使うとマクロ内の(list x y)が誤動作する
    ...)

こういうのも含めて自動で衝突を回避するのがhygienicだと。

またモジュールシステムをもつ処理系の場合、マクロがモジュールローカルな関数を呼び出していると、
単純な展開ではうまくいかないという話(CLのシンボルに名前空間あるのはこのためかぁ）。

### wasabiz 16:44

- http://wasabiz.hatenablog.com/entry/20120331/1333209310 
  2012-03-31 syntactic closureは内部でどのように実装されているのか 

- http://wasabiz.hatenablog.com/entry/2013/11/28/233055
  2013-11-28 picrinに衛生的マクロを追加しました

  - α変換の上にsyntactic-closureを乗せる「素朴な手法」とのこと 
    (sc-macro-transformer)
  - これをベースとしてER, IRを実装 
  - src/macro.cを参照のこと

- http://wasabiz.hatenablog.com/entry/2014/01/23/160725 
  2014-01-23 picrin scheme開発メモ

  - ERをSCベースから、native APIに変更した
    ERの「ある基準」を満たせなかったため

- http://wasabiz.hatenablog.com/entry/2014/09/28/145739 
  2014-09-28 健全なマクロは壊れている 

## 2016/06/29

### syntax-rules(2) 14:25

http://d.hatena.ne.jp/mjt/20110302/p1

- Hygienicなものしか書けない
  - syntax-rules
- Hygienicでないものも書ける
  - define-macro(伝統的マクロ)
  - syntactic-closure + ER(explicit renaming)  - MIT, Chicken, Chibi等
  - syntax-case (R6RS)

- 3引数ER(変換対象の式、compare、rename)

そのあとの議論はよくわからない…。identifierとsymbolの違いとは。
4引数のERというものが提案されている。
  - 3ER: シンボルを書くと、そのまま出力される
  - 4ER: 「そのまま出力」したいときはinjectで明示する

### http://wiki.call-cc.org/man/4/Macros

- Chikenのサイト。ER, IRの説明がある

### https://github.com/ashinn/chibi-scheme/blob/7f1786f85443d21252c92867137df81713e59209/lib/init-7.scm#L97

ChibiのERの実装。make-syntactic-closureという関数？が基礎となっているようだ。

opcodes.cを見ると、sexp_make_synclo_opという中間コードになるのかな？

## 2016/06/22

### syntax-rules 01:38

だいたいこんな感じ。

(define-syntax test
  (syntax-rules ()
    ((test name expr)  ; パターン
     (unless expr      ; 展開結果。name, exprは束縛されたものに展開される
       (print name " failed: " (quote expr))))))


- (syntax-rules foo ()
    ((パターン) テンプレート)) 
  という形式があるらしい。
  あー、「...」が出てくるようなパターンのときに使うのか。

- パターンは以下のいずれか
  (a b c)
  (a b c . d)
  (a b c ... d e f)
  (a b c ... d e f . g)
  #(a b c)
  #(a b c ... d e f)
  - identifierのうち、以下は特別
    _
    リテラルで指定したもの
    ...
  - それ以外の識別子はpattern variableと呼ぶ(上のname, expr)
    ただしパターンの最初のkeywordはマッチには関与せず、pattern 
    variableとも呼ばない
  - pattern variableはパターン内で重複してはいけない
  - underscoreはpattern variableでないので、参照ができない
    パターン内で何度出てきてもよい
    - underscoreをliteralに指定するのは合法
  - literal
    (define-syntax foo
      (syntax-rules (LIT)
        ((_ LIT) テンプレート)))
    (foo LIT)

    - リテラルで指定したものがマッチする条件

- テンプレートは以下のいずれか
  identifier
  constant
  (a b c)
  (a b c . テンプレート)
  (... テンプレート)
  #(a b c)
  - ここで、a, b, cはテンプレートまたは「テンプレート ...」

- (test "Test1" (= 1 2)) という式を、パターンにマッチさせる

----


# Fomentを読む

## 目的

syntax-rulesの実装がどうなっているのか調べる。

~/rr_2016/foment/src/synrules.cpp

# Fomentを読む(8)

http://yhara.jp/ReadingFoment

12月号です。前回何やったか全然覚えてないけど、記事末のまとめ部分を読めば思い出すというシステムになっている。

> 今回は構造体FSyntaxRules, FSyntacticEnvの定義を見た。
> 次回は未定だけど、sytnax-rules固有の仕様よりは、hygenic macroに共通した部分のコードを先に調べたいという気持ちがある。

とのこと。とりあえず両構造体の定義を再掲。

```c
typedef struct
{
    FRecord Record;
    FObject Literals;
    FObject Rules;
    FObject SyntacticEnv;
} FSyntaxRules;

typedef struct
{
    FRecord Record;
    FObject GlobalBindings;
    FObject LocalBindings;
} FSyntacticEnv;
```

SyntaxRulesオブジェクトがSyntacticEnvへの参照を持っていることがわかる。

## SyntacticEnvとは

そろそろSyntacticEnvの説明を書いたほうがいい気がする。検索すると[SchemeWikiのページ](http://community.schemewiki.org/?syntactic-closures)が出てくる。うん、これは一回読んだ気がする。あとは[Wikipedia](https://en.wikipedia.org/wiki/Syntactic_closure)にページがあるっぽい。

要するに以下のようなマクロ呼出しがあったときに、マクロ展開後もfooとbarが「こっちの」fooとbarを指すようにしたい、ということみたい。もしかしたらマクロ定義内でfooという名前を使っているかもしれないけど、そっちのfooは展開後も「あっちの」fooを指す。

    (some-macro foo bar)


## FSyntacticEnv

それ以外ではFSyntacticEnvはどこで使われているのだろうか？

- synpass.cpp
- synrules.cpp
- compile.cpp
- library.cpp

### library.cpp

MakeSyntacticEnvしている箇所がいくつかある。

- ExpandLibraryDeclarations
- CompileTransformer
- CompileEvalExpr
- CondExpandProgram
- CompileProgram


# [scheme] Fomentを読む(7)

http://yhara.jp/ReadingFoment

一月経ったので続きを。前回はCompileSyntaxRules, ExpandSyntaxRulesのシグネチャを調べたのだった。

- CompileSyntaxRules(FSyntacticEnv se, expr) -> FSyntaxRules
- ExpandSyntaxRules(FSyntacticEnv se, FSyntaxRules sr, expr) -> expr

次は何をすれば良いかなぁ。

- FSyntacticEnvの定義を調べる？
- FSyntaxRules(syntax-rulesオブジェクト)の定義を調べる？
- ExpandSyntaxRulesで、FSyntacticEnvを使っている箇所を調べる？

まあこんなところかな。

## FSyntaxRules

FSyntaxRulesはsynrules.cppに定義があった。

```c
typedef struct
{
    FRecord Record;
    FObject Literals;
    FObject Rules;
    FObject SyntacticEnv;
} FSyntaxRules;
```

メンバ名もUpperCamelCaseなんだな...。そして例によって型がFObjectなので実際の(Shcemeレベルでの)型が何なのか分からないという。Ruleは、同ファイルにFSyntaxRuleという構造体があるからそれの配列かな？

```c
typedef struct
{
    FRecord Record;
    FObject NumVariables;
    FObject Variables; // A list of pattern variables.
    FObject Pattern;
    FObject Template;
} FSyntaxRule;
```

最初のメンバがいずれも`FRecord Record;`だから、これは何らかの基盤側の仕組みで、レコード型のメンバではないのだろうな。

## FSyntacticEnv

FSyntacticEnvの方はcompile.hppに定義があった。

```c
typedef struct
{
    FRecord Record;
    FObject GlobalBindings;
    FObject LocalBindings;
} FSyntacticEnv;
```

Recordはメンバではないとすると、GlobalBindingsとLocalBindingsの組らしい。これらの型はなんだろうか。

## GlobalBindings, LocalBindingsの型

compile.cppにMakeSyntacticEnvという関数がある。そこを見ると、GlobalBindingsの型が分かりそうな箇所が。

```c
    if (EnvironmentP(obj))
    {
        se->GlobalBindings = obj;
        se->LocalBindings = EmptyListObject;
    }
```

EnvironmentPはfoment.hppで定義されている。

```c
#define EnvironmentP(obj) RecordP(obj, R.EnvironmentRecordType)
```

つまりGlobalBindingsの型はFEnvironmentであるようだ。この構造体もfoment.hppにある。

```c
typedef struct
{
    FRecord Record;
    FObject Name;
    FObject HashMap;
    FObject Interactive;
    FObject Immutable;
} FEnvironment;
```

LocalBindingsもおそらくは同じ型だろう。

## まとめ

今回は構造体FSyntaxRules, FSyntacticEnvの定義を見た。
次回は未定だけど、sytnax-rules固有の仕様よりは、hygenic macroに共通した部分のコードを先に調べたいという気持ちがある。

# [scheme] Fomentを読む(6)

月一でやろうかなと言っていたけど、先月はちょっと忙しくて休載した。ということで10月分。

前回はsynrules.cppの提供する2つの関数、CompileSyntaxRulesとExpandSyntaxRulesについて、どの補助関数が呼ばれているかを調べたのだった。次は何をしようかなぁ。とりあえずこれらの関数の引数と返り値が知りたいな。

## ExpandSyntaxRules

synrules.cppを見る。ExpandSyntaxRulesはExpandTemplateの結果を返す。ExpandTemplateはMakePairかListToVectorの結果を返すので、Schemeレベルの値を返すっぽい。

引数の方はどうだろうか。ぜんぶFObjectだから分かんないんだよな...。綺麗なコードだと言ったけど、Cなのに事実上型がないような感じでつらみが出てきた。

```
FObject ExpandSyntaxRules(FObject se, FObject sr, FObject expr)
```

ともあれsrは`FAssert(SyntaxRulesP(sr));`とあるので、foment.hppにあるSyntaxRulesRecordTypeによると、レコード型SyntaxRulesRecordTypeっぽい。

## レコード型について

時間が空いたので再度まとめておくが、RecordTypeはMakeRecordTypeCから作られるもので、

    R.SyntaxRulesRecordType = MakeRecordTypeC("syntax-rules",
            sizeof(SyntaxRulesFieldsC) / sizeof(char *), SyntaxRulesFieldsC);

MakeRecordによってFXxxXxxのようなインスタンスを作成できる。

    FSyntaxRules * sr = (FSyntaxRules *) MakeRecord(R.SyntaxRulesRecordType);

ややこしいので、このシリーズではレコード型はFSyntaxRulesみたいな名前で統一しようかな。

## ExpandSyntaxRulesのシグネチャ

ここまでで分かっているExpandSyntaxRulesのシグネチャは以下。

    ExpandSyntaxRules(se, FSyntaxRules sr, expr) -> PairとかVectorとか

exprはSchemeの式なのだろう。seはMatchPatternの第一引数で、MatchReferenceの第二引数である。MatchReferenceはsynpass.cppにあった。seはResolveIdentifierの第一引数。ResolveIdentifierには以下のアサーションがあるので、FSyntacticEnvだと分かった。

        FAssert(SyntacticEnvP(se));

## FSyntacticEnv

FSyntacticEnvはたぶん、syntactic closure関係の何かだと思う。syntactic closureについては僕も説明できるほど理解していない(理解してたらfomentの実装とか読んでない)ので、知りたい人はググるか、ポインタとしてはこちらの記事などを。

- http://athos.hatenablog.com/entry/20120506/syntactic_closure_in_clojure

このシリーズでもいずれ説明することになる、はず。

## CompileSyntaxRulesのシグネチャ

CompileSyntaxRulesの方は以下のようなシグネチャだった。

- CompileSyntaxRules(FObject se, FObject obj) -> FObject

synpass.cppでの使用箇所を見るとseはFSyntacticEnv、objはSchemeの式(expr)っぽい。また返り値はMakeSyntaxRulesなのでFSyntaxRules。ということでこうなる。

- CompileSyntaxRules(FSyntacticEnv se, expr) -> FSyntaxRules

## CompileSyntaxRulesの使い方

synpass.cppのSPassSpecialSyntaxという関数に使用箇所がある。

- SPassSpecialSyntax(FObject enc, FSyntacticEnv se, ss, expr)

ここではquote, lambda, if, set!, let, let*などの組み込みの構文と、syntax-rulesによるユーザ定義構文を処理しているようだ。`(syntax-rules xxx)`のようなS式だったらそれをFSyntaxRulesにコンパイルするということかな。

```
    else if (ss == DoSyntax)
    {
        // (do ((<variable> <init> [<step>]) ...) (<test> <expression> ...) <command> ...)

        return(SPassDo(enc, se, expr));
    }
    else if (ss == SyntaxRulesSyntax)
    {
        // (syntax-rules (<literal> ...) <syntax rule> ...)
        // (syntax-rules <ellipse> (<literal> ...) <syntax rule> ...)

        return(CompileSyntaxRules(MakeSyntacticEnv(se), expr));
    }
```

## ExpandSyntaxRulesの使い方

上記の関数SPassSpecialSyntaxは、同じsynrules.cppのSPassExpressionから呼ばれている。ここを見るとExpandSyntaxRulesの方の呼び出しもあった。`(foo 1 2 3)`みたいな式があって、fooがsytnax-rulesで定義された構文だったら、これをExpandSyntaxRulesで展開するということのようだ。

```
            val = EnvironmentGet(AsReference(op)->Binding, AsReference(op)->Identifier);
        }

        if (SpecialSyntaxP(val))
            return(SPassSpecialSyntax(enc, se, val, expr));

        if (SyntaxRulesP(val))
            return(SPassExpression(enc, se, ExpandSyntaxRules(se, val, Rest(expr))));
```

## まとめ

今回は前にやった内容を思い出しつつ、CompileSyntaxRulesとExpandSyntaxRulesのシグネチャを調べた。コールグラフとともに再掲しておく。

```
- CompileSyntaxRules(FSyntacticEnv se, expr) -> FSyntaxRules
  - CopyLiterals
    - LiteralFind
  - CompileRule
    - CompilePatternVariables
      - PatternVariableFind, LiteralFind
    - AssignVariableIndexes
    - CompilePattern
      - PatternVariableFind, LiteralFind
      - CountPatternsAfterRepeat
      - RepeatPatternVariables
        - PatternVariableFind
    - CompileTemplate
      - PatternVariableFind
      - AddVarToTemplateRepeat
        - ListFind

- ExpandSyntaxRules(FSyntacticEnv se, FSyntaxRules sr, expr) -> expr
 - MatchPattern
   - InitRepeatVariables
   - GatherRepeatVariables
 - ExpandTemplate
   - CheckRepeatVariables
   - SetRepeatVariables
   - ExpandTemplateRepeat -> ExpandTemplateを呼ぶことがある(相互再帰)
```

## 2016/08/13

# [scheme] Fomentを読む(5)

前回からだいぶ間が空いた。ちょっと別にやりたいことができたので、実を言うとこっちは休載しようと思っていたのだけど、月一ペースで更新するというのも

前回はExpandSyntaxRulesの他にCompileSyntaxRulesという関数がエクスポートされていることを発見したのだった。

なのでsynrules.cppのたくさんの関数は、もしかしたら2種類に分類できるかもしれない。今回はそのあたりを見ていく。

## 関数一覧

一覧を再掲する。引数のうち、型名が省略されているものはFObject。

```
static FObject LiteralFind(se, list, obj)
static FObject CopyLiterals(se, obj, ellip)
static FObject PatternVariableFind(se, list, var)
static FObject CompilePatternVariables(se, form, lits, pat, ellip, pvars, int_t rd)
static void AssignVariableIndexes(pvars, int_t idx)
static int_t CountPatternsAfterRepeat(pat)
static FObject RepeatPatternVariables(se, pvars, pat, rvars)
static FObject CompilePattern(se, lits, pvars, ellip, pat)
static int_t ListFind(list, obj)
static int_t AddVarToTemplateRepeat(var, trs)
static FObject CompileTemplate(se, form, pvars, ellip, tpl, trs, int_t qea)
static FObject CompileRule(se, form, lits, rule, ellip)
FObject CompileSyntaxRules(se, obj)

static void InitRepeatVariables(vars, vals[], rvals[])
static void GatherRepeatVariables(vars, vals[], rvals[])
static int_t MatchPattern(se, cpat, vals[], expr)
static int_t CheckRepeatVariables(vars, vals[], expr)
static void SetRepeatVariables(vars, vals[], rvals[])
static FObject ExpandTemplateRepeat(tse, use, ctpl, int_t nv, vals[], int_t rc, ret, expr)
static FObject ExpandTemplate(tse, use, ctpl, int_t nv, vals[], expr)
FObject ExpandSyntaxRules(se, sr, expr)
```

CompileSyntaxRulesとExpandSyntaxRulesだけがこのファイル外にエクスポートされているのだった。それ以外はprivate的な補助関数というわけだが、もしかしてこれ、ファイルの前半と後半で綺麗に分けてありますか？

試しに、InitRepeatVariables以下の関数がどこから呼ばれているかを確認してみる。やはり、ファイル後半にあるのはすべてExpandSyntaxRulesの方の補助関数だった。いやあ、こういうのを綺麗なソースっていうんですよね(嬉)

## コールグラフ

作成したコールグラフは以下。各補助関数がどの関数から呼ばれているかを調べて、それを木にしたもの。

```
- ExpandSyntaxRules
 - MatchPattern
   - InitRepeatVariables
   - GatherRepeatVariables
 - ExpandTemplate
   - CheckRepeatVariables
   - SetRepeatVariables
   - ExpandTemplateRepeat
     - ExpandTemplate(相互再帰)
```

CompileSyntaxRulesの方もやってみよう。

```
- CompileSyntaxRules
  - CopyLiterals
    - LiteralFind
  - CompileRule
    - CompilePatternVariables
      - PatternVariableFind, LiteralFind
    - AssignVariableIndexes
    - CompilePattern
      - PatternVariableFind, LiteralFind
      - CountPatternsAfterRepeat
      - RepeatPatternVariables
        - PatternVariableFind
    - CompileTemplate
      - PatternVariableFind
      - AddVarToTemplateRepeat
        - ListFind
```

こっちのほうが少しでかそう。

## 2016/07/14

# [scheme] Fomentを読む(4)

[前回](20160713#p02)からの続き。前回はsyntax-rulesを構成していそうな関数をリストアップしたのだった。

## 関数一覧

一覧を再掲する。ただし引数がFObjectであるものは型名を省略した。

```
static FObject LiteralFind(se, list, obj)
static FObject CopyLiterals(se, obj, ellip)
static FObject PatternVariableFind(se, list, var)
static FObject CompilePatternVariables(se, form, lits, pat, ellip, pvars, int_t rd)
static void AssignVariableIndexes(pvars, int_t idx)
static int_t CountPatternsAfterRepeat(pat)
static FObject RepeatPatternVariables(se, pvars, pat, rvars)
static FObject CompilePattern(se, lits, pvars, ellip, pat)
static int_t ListFind(list, obj)
static int_t AddVarToTemplateRepeat(var, trs)
static FObject CompileTemplate(se, form, pvars, ellip, tpl, trs, int_t qea)
static FObject CompileRule(se, form, lits, rule, ellip)
FObject CompileSyntaxRules(se, obj)
static void InitRepeatVariables(vars, vals[], rvals[])
static void GatherRepeatVariables(vars, vals[], rvals[])
static int_t MatchPattern(se, cpat, vals[], expr)
static int_t CheckRepeatVariables(vars, vals[], expr)
static void SetRepeatVariables(vars, vals[], rvals[])
static FObject ExpandTemplateRepeat(tse, use, ctpl, int_t nv, vals[], int_t rc, ret, expr)
static FObject ExpandTemplate(tse, use, ctpl, int_t nv, vals[], expr)
FObject ExpandSyntaxRules(se, sr, expr)
```

よく見るとstaticな関数とそうでないものが存在する。なんだっけ、staticを付けると関数のスコープがこのファイル内だけになるんだっけか。

ExpandSyntaxRulesの他にはCompileSyntaxRulesが、ファイル外にも公開されているようだ。ExpandとCompileはどう違うのだろうか。引数も返り値もFObjectだらけなので、実際に期待されている型がわかりにくいな...。

## CompileSyntaxRules, ExpandSyntaxRules

CompileSyntaxRulesは最後の行がこれなので、FSyntaxRulesを返すことが分かる。

    return(MakeSyntaxRules(lits, ReverseListModify(nr), se));

ExpandSyntaxRulesの最後の行はこれ。あれ、値を返さないのか？

    return(NoValueObject);

いや、途中にもreturnがあった。

            return(ExpandTemplate(MakeSyntacticEnv(AsSyntaxRules(sr)->SyntacticEnv), se,
            ...略


ExpandTemplateの返り値を見てみる。

```
static FObject ExpandTemplate(FObject tse, FObject use, FObject ctpl, int_t nv, FObject vals[],
    FObject expr)
{
    if (PairP(ctpl))
        return(MakePair(ExpandTemplate(tse, use, First(ctpl), nv, vals, expr),
                ExpandTemplate(tse, use, Rest(ctpl), nv, vals, expr)));

    if (VectorP(ctpl))
        return(ListToVector(ExpandTemplate(tse, use, AsVector(ctpl)->Vector[0], nv, vals, expr)));
...略
```

最初のreturnを見るとPairを返しているようだが、次のreturnはVectorを返すはず。ああそうか、引数によって違うものが返るのか。Cだけど、Schemeのコードに近いな。

## NoValueObject

さっき出てきたNoValueObject、どういうものなのか気になるので調べてみる。foment.hppに定義があった。

```
#define EndOfFileObject MakeImmediate(3, MiscellaneousTag)
#define EndOfFileObjectP(obj) ((obj) == EndOfFileObject)

#define NoValueObject MakeImmediate(4, MiscellaneousTag)
#define NoValueObjectP(obj) ((obj) == NoValueObject)

#define WantValuesObject MakeImmediate(5, MiscellaneousTag)
#define WantValuesObjectP(obj) ((obj) == WantValuesObject)
```

MakeImmediateが何をするのかは分からないが、EOFオブジェクトと定義の仕方が同じなので、たぶん他の値と絶対にeqにならない定数値を定義しているのだろう。Gaucheでいう`#<undef>`相当のものかな？



## 2016/07/11

# [scheme] Fomentを読む(3)

[前回](20160710#p01)からの続き。前回はレコード型がstructと対応していることを確認したのだった。

なんとなくデータ構造が把握できたので、次はシーケンス、つまり「何がどの順で実行されるか」の調査に入る。

まずは、syntax-rulesが呼ばれた時に最初に実行される関数を見つけたいが、synrules.cppの冒頭も末尾もどうやら違いそうだ。名前的には、下から二番目のExpandSyntaxRulesがそれっぽい感じがする。

## ExpandSyntaxRules

使われている場所をgit grepで確認する。

```
src/compile.hpp:FObject ExpandSyntaxRules(FObject se, FObject sr, FObject expr);
src/library.cpp:            return(CompileEvalExpr(ExpandSyntaxRules(MakeSyntacticEnv(env), op, Rest(obj)), env,
src/synpass.cpp:            return(SPassExpression(enc, se, ExpandSyntaxRules(se, val, Rest(expr))));
src/synpass.cpp://            return(SPassExpression(enc, se, ExpandSyntaxRules(MakeSyntacticEnv(se), val, Rest(expr))));
src/synpass.cpp:            return(SPassBodyExpression(se, ExpandSyntaxRules(se, val, Rest(expr))));
src/synpass.cpp://            return(SPassBodyExpression(se, ExpandSyntaxRules(MakeSyntacticEnv(se), val,
src/synrules.cpp:FObject ExpandSyntaxRules(FObject se, FObject sr, FObject expr)
```

library.cppとsynpass.cppで使われているようだ。ふーむ。

SyntaxRulesをExpandしたあとのことについてはあまり興味がないのでここを追ってもしかたないかなと思いつつ、呼び出し元の関数名だけ控えておく。

- library.cpp
  - static FObject CompileEvalExpr(FObject obj, FObject env, FObject body)
- synpass.cpp
  - static FObject SPassExpression(FObject enc, FObject se, FObject expr)
  - static FObject SPassBodyExpression(FObject se, FObject expr)

## synrules.cpp

ファイル内のエントリポイントが分かったので、次はファイル内の概要を把握しよう。
関数宣言の一覧を作る。

```
static FObject MakeSyntaxRules(FObject lits, FObject rules, FObject se)
static FObject MakePatternVariable(int_t rd, FObject var)
static FObject MakePatternRepeat(int_t lc, FObject ellip, FObject vars, FObject pat,
static FObject MakeTemplateRepeat(FObject ellip, int_t rc)
static FObject MakeSyntaxRule(int_t nv, FObject vars, FObject pat, FObject tpl)
```

このへんまでは単なるデータのコンストラクタだろう。したがってこれ以降がsyntax-rulesの本体と思われる。

```
static FObject LiteralFind(FObject se, FObject list, FObject obj)
static FObject CopyLiterals(FObject se, FObject obj, FObject ellip)
static FObject PatternVariableFind(FObject se, FObject list, FObject var)
static FObject CompilePatternVariables(FObject se, FObject form, FObject lits, FObject pat, FObject ellip, FObject pvars, int_t rd)
static void AssignVariableIndexes(FObject pvars, int_t idx)
static int_t CountPatternsAfterRepeat(FObject pat)
static FObject RepeatPatternVariables(FObject se, FObject pvars, FObject pat, FObject rvars)
static FObject CompilePattern(FObject se, FObject lits, FObject pvars, FObject ellip, FObject pat)
static int_t ListFind(FObject list, FObject obj)
static int_t AddVarToTemplateRepeat(FObject var, FObject trs)
static FObject CompileTemplate(FObject se, FObject form, FObject pvars, FObject ellip, FObject tpl, FObject trs, int_t qea)
static FObject CompileRule(FObject se, FObject form, FObject lits, FObject rule, FObject ellip)
FObject CompileSyntaxRules(FObject se, FObject obj)
static void InitRepeatVariables(FObject vars, FObject vals[], FObject rvals[])
static void GatherRepeatVariables(FObject vars, FObject vals[], FObject rvals[])
static int_t MatchPattern(FObject se, FObject cpat, FObject vals[], FObject expr)
static int_t CheckRepeatVariables(FObject vars, FObject vals[], FObject expr)
static void SetRepeatVariables(FObject vars, FObject vals[], FObject rvals[])
static FObject ExpandTemplateRepeat(FObject tse, FObject use, FObject ctpl, int_t nv, FObject vals[], int_t rc, FObject ret, FObject expr)
static FObject ExpandTemplate(FObject tse, FObject use, FObject ctpl, int_t nv, FObject vals[], FObject expr)
FObject ExpandSyntaxRules(FObject se, FObject sr, FObject expr)
```

長い！こんなに関数があったのか。でも幸いめちゃめちゃ長い関数はなかったので、次回は関数同士の呼び出し関係を調べるところからやる(かもしれないし、気分次第で別のことをするかもしれない)。

## 2016/07/10

# [scheme] Fomentを読む(2)

[前回](20160709#p01)からの続き。前回はリビジョンを書くのを忘れたが、[現時点のgit master](https://github.com/leftmike/foment/commit/cae95546e8ef9746eefac5b010f98972f95eee5a)を手元にダウンロードして読んでいる。

昨日はsyntax-rulesからだいぶ離れてしまったので、またsynrules.cppから見ていこう。

```
void SetupSyntaxRules()
{
    R.SyntaxRulesRecordType = MakeRecordTypeC("syntax-rules",
            sizeof(SyntaxRulesFieldsC) / sizeof(char *), SyntaxRulesFieldsC);
    R.PatternVariableRecordType = MakeRecordTypeC("pattern-variable",
            sizeof(PatternVariableFieldsC) / sizeof(char *), PatternVariableFieldsC);
    R.PatternRepeatRecordType = MakeRecordTypeC("pattern-repeat",
            sizeof(PatternRepeatFieldsC) / sizeof(char *), PatternRepeatFieldsC);
    R.TemplateRepeatRecordType = MakeRecordTypeC("template-repeat",
            sizeof(TemplateRepeatFieldsC) / sizeof(char *), TemplateRepeatFieldsC);
    R.SyntaxRuleRecordType = MakeRecordTypeC("syntax-rule",
            sizeof(SyntaxRuleFieldsC) / sizeof(char *), SyntaxRuleFieldsC);
}
```

## レコード型

ここでは5つのレコード型を定義している。

- SyntaxRuleRecordType
- PatternVariableRecordType
- PatternRepeatRecordType
- TemplateRepeatRecordType
- SyntaxRuleRecordType

型名は分かったが、フィールドの定義はどこにあるのだろう。それぞれSyntaxRulesFieldsCのようなシンボルを渡しているので、これを確認してみよう。

同じファイルを「FieldsC」で検索すると以下が見つかった。

```
static const char * SyntaxRulesFieldsC[] = {"literals", "rules", "syntactic-env"};
static const char * PatternVariableFieldsC[] = {"repeat-depth", "index", "variable"};
static const char * PatternRepeatFieldsC[] = {"leave-count", "ellipsis", "variables", "pattern",
static const char * TemplateRepeatFieldsC[] = {"ellipsis", "repeat-count", "variables", "template",
    "rest"};
static const char * SyntaxRuleFieldsC[] = {"num-variables", "variables", "pattern", "template"};
```

整理しておこう。

- SyntaxRules = (literals, rules, syntactic-env)
- PatternVariable = (repeat-depth, index, variable)
- PatternRepeat = (leave-count, ellipsis, variables, pattern)
- TemplateRepeat = (ellipsis, repeat-count, variables, template, rest)
- SyntaxRule = (num-variables, variables, pattern, template)

メンバ名から察するに、以下の様な階層構造だと思われる。

- SyntaxRules = (literals, rules, syntactic-env)
  - SyntaxRule = (num-variables, variables, pattern, template)
    - PatternVariable = (repeat-depth, index, variable)
    - PatternRepeat = (leave-count, ellipsis, variables, pattern)
    - TemplateRepeat = (ellipsis, repeat-count, variables, template, rest)

## struct

一方でsynrules.cppでは以下のようなstructも定義されている。これとレコード型はどのような関係なのだろうか？

```
typedef struct
{
    FRecord Record;
    FObject Literals;
    FObject Rules;
    FObject SyntacticEnv;
} FSyntaxRules;
```

synrules.cppで定義されているstructは以下。全部のレコード型にstructがあるわけではないようだ。

- FSyntaxRules
- FSyntaxRule

FSyntaxRulesの定義の下に、MakeSyntaxRulesという関数がある。これによると、MakeRecordで生成したレコードを、struct FSyntaxRulesで受けられるらしい。

    FSyntaxRules * sr = (FSyntaxRules *) MakeRecord(R.SyntaxRulesRecordType);
    sr->Literals = lits;
    sr->Rules = rules;
    sr->SyntacticEnv = se;

synrules.cppをMakeRecordで検索すると、FPatternVariable, FPatternRepeat, FTemplateRepeatという識別子も存在することがわかる。これらの定義はsynrules.cppには無いが、compile.hppにあることが分かった。例えばFTemplateRepeatの定義は以下である。

```
typedef struct
{
    FRecord Record;
    FObject Ellipsis;
    FObject RepeatCount;
    FObject Variables;
    FObject Template;
    FObject Rest;
} FTemplateRepeat;
```

一方でTemplateRepeatFieldsCの定義は以下だったので、見比べると、最初の`FRecord Record`以外はレコード型のフィールド名と対応していることがわかる。

    static const char * TemplateRepeatFieldsC[] = {"ellipsis", "repeat-count", "variables", "template",

ということで最初の疑問の答えだが、レコード型の値をMakeRecordで作成すると対応するstructの値が得られる、ということで良さそうだ。


## 2016/07/09

# [scheme] Fomentを読む(1)

syntax-rulesの実装方法について調べるために、[Foment](https://github.com/leftmike/foment/)というR7RS処理系のソースを読んでみることにした。

せっかくなので、コードリーティングの際に何をしているかを実況のような感じで書いてみたい。飽きたらやめるけど。

## ファイル構成

まず最初に、全体のファイル構成を把握する。それぞれのファイルをちらっとだけ見て、何が書いてありそうかをメモしておく。

Fomentの場合はファイル数が少ないので楽だった。

```
- src/
  - main.cpp
  - base.scm
  - txt2cpp.cpp
  - license.txt

  - コア
    - compile.cpp
    - compile.hpp
    - execute.cpp
    - execute.hpp
    - foment.cpp
    - foment.hpp
    - gc.cpp
    - io.cpp
    - io.hpp
    - library.cpp
    - genpass.cpp
    - midpass.cpp
    - synpass.cpp
    - mini-gmp.c
    - mini-gmp.h
    - synrules.cpp
    - unicode.cpp
    - unicode.hpp
    - unidata.hpp

  - ライブラリ
    - chars.cpp
    - compare.cpp
    - filesys.cpp
    - hcontain.cpp
    - numbers.cpp
    - numbers.hpp
    - pairs.cpp
    - read.cpp
    - strings.cpp
    - syncthrd.cpp
    - syncthrd.hpp
    - vectors.cpp
    - write.cpp
- test/
  - テスト
- unix/
  - makefile
- windows/
  - makefile等
- LICENSE
- README.md
```

src以下に全ての.cpp, .hppが入っているようだが、できればcoreとlibraryとかに分けてほしいな。

## synrules.cpp

名前からすると、src/synrules.cppというファイルにsyntax-rulesのソースがありそうだ。拡張子がcppなのでC++だと思うが、わりと独自の世界観というか、普通のC++の書き方ではないようで面白い。

ファイル末尾で、構造体を定義している。構造体と言ってもCのstructというよりは、R7RS Recordの可能性が高そうだ。

    R.SyntaxRulesRecordType = MakeRecordTypeC("syntax-rules",
            sizeof(SyntaxRulesFieldsC) / sizeof(char *), SyntaxRulesFieldsC);

Rというのは何だろうか。ちょっと検索がしづらいが、ソース内でグローバルに見える変数だろうから、foment.cppあたりを探してみると、以下の定義があった。

    FRoots R;

Rの中身はsyntax-rulesの実装には直接関係ないような予感がするけれど、正体が分かっているものがたくさんあった方がソースは読みやすいので、ちょっと調べてみよう。

## FRoots R

`git grep FRoots`でFRootsの定義を探すとfoment.hppにあった。このファイルの冒頭にはTODOリストがある。いちばん最初は1ファイルで開発していたのかもしれない。

FRootsは以下のような構造体だった。グローバルな変数の置き場なのだろうか。

```
// ---- Roots ----

typedef struct
{
    FObject Bedrock;
    FObject BedrockLibrary;
    FObject Features;
    FObject CommandLine;
略...
    FObject DatumReferenceRecordType;
} FRoots;
```

余談だが「// ---- Roots ----」のように要所要所に区切りが書いてあるのを見つけると嬉しくなる。単に見やすいだけでなく、コードを整理しようという意志が感じられるからだ。

## FObject

ついでなのでFObjectの定義も確認してみる。が、単にvoid *のtypedefだった。へえ。

    typedef void * FObject;

## MakeRecordTypeC

synrules.cppの以下の行を見ていたのだった。

    R.SyntaxRulesRecordType = MakeRecordTypeC("syntax-rules",
            sizeof(SyntaxRulesFieldsC) / sizeof(char *), SyntaxRulesFieldsC);

Rがどういうものかなんとなく分かったので、次はMakeRecordTypeCを調べてみる。これもfoment.cppに定義があった。

```
FObject MakeRecordTypeC(const char * nam, uint_t nf, const char * flds[])
{
    FObject oflds[32];

    FAssert(nf <= sizeof(oflds) / sizeof(FObject));

    for (uint_t fdx = 0; fdx < nf; fdx++)
        oflds[fdx] = StringCToSymbol(flds[fdx]);

    return(MakeRecordType(StringCToSymbol(nam), nf, oflds));
}
```

すぐ上にはMakeRecordTypeという関数がある。Cというsuffixは何かなと思ったが、第一引数の型が違うようだ。C++のCか、CharのCあたりだろうか。

- FObject MakeRecordType(FObject nam, uint_t nf, FObject flds[])
- FObject MakeRecordTypeC(const char * nam, uint_t nf, const char * flds[])

すぐ下では%make-record-typeという何かを定義している。「%」を頭に付けるのはSchemeのコードでわりと見られる命名なので、おそらくDefineというマクロを使うとSchemeレベルの関数が定義されるのであろう。

```
Define("%make-record-type", MakeRecordTypePrimitive)(int_t argc, FObject argv[])
{
    // (%make-record-type <record-type-name> (<field> ...))

    FMustBe(argc == 2);

    SymbolArgCheck("define-record-type", argv[0]);
...略
    return(MakeRecordType(argv[0], VectorLength(flds), AsVector(flds)->Vector));
}
```

R7RSにはdefine-record-typeという構文があるので、きっとそこからこの%make-record-typeが呼ばれそうな気がする。git grepでdefine-record-typeを探すと、src/base.scmにそのような定義があった。

        (define-syntax define-record-type
            (syntax-rules ()
                ((define-record-type type (maker arg ...) predicate field ...)
                    (begin
                        (define type (%make-record-type 'type '(field ...)))
                        (define maker (define-record-maker type () () arg ...))
                        (define (predicate obj) (%record-predicate type obj))
                        (define-record-field type field) ...))))

## Define

このDefineというのは構文みたいに見えるけど、C++にはこんな記法はないので、どこかにマクロ定義があるはず。きっとfoment.cppかhppだろう。

    Define("%make-record-type", MakeRecordTypePrimitive)(int_t argc, FObject argv[])

hppの方だった。この例だとnameが`"%make-record-type"`、primがMakeRecordTypePrimitiveに対応する。

```
#define Define(name, prim) \
    EternalSymbol(prim ## Symbol, name); \
    static FObject prim ## Fn(int_t argc, FObject argv[]);\
    static FEternalPrimitive prim ## Object = { \
        .ObjHdr.FlagsAndSize = OBJHDR_GEN_ETERNAL | sizeof(FPrimitive), \
        .ObjHdr.TagAndSlotCount = (PrimitiveTag << OBJHDR_TAG_SHIFT) | 1, \
        .Primitive.Name = prim ## Symbol, \
        .Primitive.PrimitiveFn = prim ## Fn, \
        .Primitive.Filename = __FILE__, \
        .Primitive.LineNumber =__LINE__, \
        .ObjFtr.Feet = {OBJFTR_FEET, OBJFTR_FEET} \
    }; \
    FObject prim = &prim ## Object.Primitive; \
    static FObject prim ## Fn
```

`Define("foo", FooPrimitive)`のようにすると、以下のようなものが定義されるようだ。

- EternalSymbol(FooPrimitiveSymbol, "foo");
- FEternalPrimitive FooPrimitiveObject
- FObject FooPrimitive = &FooPrimitiveObject.Primitive;
- FObject FooPrimitiveFn

こうやって対象領域のために言語を拡張するのはLispプログラマらしい感じがする。

EternalSymbolの定義もfoment.hppにある。たぶん、Schemeプログラムの最初から最後まで存在するシンボルオブジェクトがEternalSymbolなのだろう。

今日のところはここまで。
