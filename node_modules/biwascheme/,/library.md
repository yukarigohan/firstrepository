# R7RS library

o ゴール
  - メインプログラムをimportから始められる
  - ライブラリを定義でき、importするとその名前が使えるようになる

o 実装ステップ
  o 最小限のライブラリ機能を実装する
    - ライブラリ側はexportとbeginのみ対応(import禁止)
    - 対応する環境：(最初は以下のいずれかだけ実装する)
      a. ブラウザ(同ファイル)
      b. ブラウザ(リモートファイル)
      c. Node.js
    - 既存の名前は(biwa compat)に入っているものとする

  o 細かいものを足す
    - ライブラリ内から別のライブラリをimportできるようにする
    - ライブラリscheme base等を定義する
    - (biwa compat)を適切に分割する
    - exportのrenameに対応
    - importのonly, except, prefix, renameに対応
    - include, include-ci, include-library-declarations
    - cond-expand

----

## 2017/03/10

###  19:32

  - ライブラリ内でグローバル変数に書き込むことは許されているか？(いなさそう..)
    => 明記されてない気がするけど、chibiでは動かなかった(前の値しか取れない)

### Envはどこに属することになるか？ 00:35

いまはBiwaScheme.TopEnvにぜんぶ入っているけど：
- 各ライブラリがEnvを持つ

  (define-library (example grid)
    (export make-grid など)
    (import (scheme base)
            (rename (example life) (life make-life)))
    (begin
      (define (make-grid arg) ....)
      ....)
  (define-library (example life)
    (export make-life))

- (example grid)のEnv:
  - make-grid => (関数)
  - make-life => (example lifeのEnvのlifeをコピーする？)
    - コピーじゃなくてもいいけど、chibiは挙動を考えるとコピーしてそう
    - コピーじゃない場合、「これはexample lifeのEnvのlifeを見る」みたいな
      情報を入れておくことになるけど、それって基本変化しないので、
      直接参照してしまう方が効率的だろうなぁ
  - displayとか => (scheme baseのdisplayを参照)

- メインプログラムのEnv:
  - intpがEnvを持つのがいいかなぁ。
    - pros: intpを複数作れば環境を分けられる
    - cons: 全部のintpで共通して関数を使わせるみたいなことが難しい
      - まあライブラリあればいいかな
    - cons: intpをnewしてる箇所が壊れそう
      - 要注意(newでenvを引数に渡すなど)
  - make-grid => (ライブラリexample gridのEnvのmake-gridを参照する)
  - displayとか => (scheme baseのdisplayを参照)

というのがR7RSだけど、互換モードの場合はどうする？いまあるライブラリが全部importされたものと考えればいいか。

### ということは  00:33

- ライブラリといっても、各変数に対応する値がメモリ上に一つだけ存在するという点は同じ。
  - 名前が外に見えたり、外の名前が見えたりする点だけが違う。
  - ここでいう名前はglobal-variableのみ(TopEnvに入っているやつ)。
    local variableはexportできないため。
    なのでfind-freeとかはいじらなくて済むかも。

## 2017/03/09

### カウンタを作って二箇所で読み込んだときどうなる？ 23:02

,/library/counter/

わかったこと

- ライブラリローカルな変数をライブラリ関数経由でset!することは可能
- ライブラリローカルな変数をexportすることも可能だけど、
  「最新の値」は取れなかった(ちゃんとgetter経由でアクセスしないといけない)
- counterライブラリを二箇所からimportしても、カウンタ値は一個だけ

### おさらい 22:23

- ライブラリは以下からなる
  - コード
  - exportする名前の一覧
  - importする名前の一覧

- ライブラリを評価するには？
  1. include-*, cond-expandを展開する
  1. import欄を見て、依存するライブラリを読み込む
  1. 読み込めたら、取り込む名前の一覧を作る
  1. 本体の評価を行う
  1. exportすべき名前がちゃんと定義されたか確認

- 本体の評価時に気をつけること
  - 名前が適切に管理されなくてはならない。つまり：
    - exportしてない名前は外に漏れてはいけない
    - exportした名前は、外から参照できないといけない
    - importした名前が見えないといけない
      ＝importした名前を参照したとき、...何が起こる？

### ライブラリ？ 22:01

何を実装したらいいんだろうか。
つまり、単なるloadと何が違うか。

  (define-library (example grid)
    (export make-grid など)
    (import (scheme base) (example life))
    (begin
      (define (make-grid arg) ....)
      ....)

- ライブラリは何からできているか
  o include-*, cond-expandはファイルから読み込んだものを書いたことになるだけだから考えなくてよさそう
  - 依存するライブラリのimport宣言
  - 本体式
    - この中では、importしたライブラリの名前が見える
      - 一部の名前だけをimportすることができる
      - renameで名前を付け替えることができる
    - この中でdefineした名前は、基本は外に出ない
  - どの名前をexportするか
    ＝このライブラリをimportしたときに、どの名前が見えるようになるか

## 2016/12/10

### internal define 21:10


