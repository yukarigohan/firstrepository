TODO
  - node: loadが相対パスを読めない

  - div0-and-mod0が2個ある
  - set-car, set-cdrが変なところにある
  - js-array->list にリネームする

  -  _InfiniteTrace: スタックトレースが無限に長くなることってないの？

Big tasks

  - _RewriteParser
    jisonかなぁ。
  - _BuildingIssue
    browserbuildかgruntか？
    gruntはwatchができる
  - _BiwaSchemeTags
    id=biwa-scriptみたいな

  - _CdnJs
    cdnjs.comに申請したい。

  -- conditions
  -- library module
  -- syntax-rules/case

!! 2012/10/26
!!! _Div0Mod0
div系のテスト書いたけど通らない。

x1, x2はreal

  x1 div x2 = nd
  x1 mod x2 = xm

  where x1 = (nd * x2) + xm で、0 <= xm <= |x2|

  x1 div0 x2 = nd
  x1 mod0 x2 = xm

  where x1 = (nd * x2) + xm で、-|x2/2| <= xm <= |x2/2|


  [+123] = +12 * [+10] + 3
  [+123] = -12 * [-10] + 3

  div  [5] = 3 * [1] + 2 
  div0 [5] = 3 * [2] - 1
           
          
      

!! 2012/10/25
!!! _RaphaelisBroken: Listを使っている箇所をチェック
あれ、全部チェックしたけど問題になる箇所がないぞ...

あー、inc!だったか。

!!! _RaphaelisBroken: diffを読む

List()をshallowにしたのが原因かぁ。
しかし考えてみると、deepって「引数にArrayが混じると誤作動する」のか(^^;

  --- a/src/library/extra_lib.js
  --- a/src/library/r6rs_lib.js
  --- a/src/system/interpreter.js
  --- a/src/system/pair.js

    before
        BS.List: 
        BS.array_to_list: List
      - BS.shallow_array_to_list: array_to_list(false)

    after

      + BS.array_to_list     : array_to_list(false)
      + BS.deep_array_to_list: array_to_list(true)

  --- a/test/unit.js
  テスト。

!!! _RaphaelisBroken
git bisectで調べたらすごい簡単だった。

  1. git bisect start
  2. git bisect bad
  3. git bisect good 0.6.1
  あとは、
    1. make
    2. ブラウザでraphaelis.htmlをリロード
    3. 動いたらbisect good, 動かなかったらbisect bad

んで、犯人は意外なコミット：
 99e28ca8220b0c004ceb498a042dcc543d760fe6 Fixed shallow vs. deep list conversion.
スタックトレース関係なかった...

!! 2012/10/16
!!! _RewriteParser

あれ、TypeScriptって手書きだったか。

!!! loadが相対パスを読めない
むー。「現在のファイル」をintpに保存しておかないと無理だなこれ。

あとnew intpで評価していいのか？と思ったけど、TopEnvが共有されるから動いてるのか...。

!!! srfi-78
とりあえずschemeで書いてみるか。

'offのときは実行しない、ってどうやって実装するんだろ？
そっか、lambdaで包むのか！

!!! テストsrfi

http://srfi.schemers.org/srfi-78/srfi-78.html check

* (check <expr> => <expected>)
* (check-ec <qualifier>* <expr> => <expected>)
* (check-report)  
  サマリと、失敗した最初のテストを表示
* (check-set-mode! mode) 
  off: do not execute any of the checks
  summary: print only summary in (check-report) and nothing else
  report-failed: report failed checks when they happen, and in summary
  report: report every example executed (Default)
* (check-reset!) カウンタを0に戻す
* (check-passed? expected-total-count)   
  exitの引数のために使うとか

http://srfi.schemers.org/srfi-64/srfi-64.html test

* (test-assert [test-name] expression)
  * (test-eqv [test-name] expected test-expr)
  * (test-equal [test-name] expected test-expr)
  * (test-eq [test-name] expected test-expr)
  * (test-approximate [test-name] expected test-expr error)
* (test-error [[test-name] error-type] test-expr)
* (test-read-eval-string string)

* (test-begin suite-name [count])
* (test-end [suite-name])
* (test-group suite-name decl-or-expr ...)
* (test-group-with-cleanup suite-name
などなど (面倒になった

!! 2012/07/27

!!! ドキュメント整備

いったんJSON(or S式)にして、そこからHTMLにレンダリングする的なのがいいかな？

だいたいの関数はソースのgrepで発見できるんじゃないか。
  define_syntax("let", function(x){
  define_libfunc("eqv?", 2, 2, function(ar){
  alias_libfunc("element-empty!", "element-clear!");




