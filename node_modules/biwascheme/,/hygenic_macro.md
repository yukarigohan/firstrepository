# 衛生的マクロ

memo/syntax_rules.md

## ゴール

- syntax-rulesが使える
  - パターンマッチ
- syntax-caseが使える(できれば)

## 実装ステップ

o syntax-caseを実装
  - パターンマッチを実装
    - 最初は、最小のパターンのみ(orやswap!が動く程度)
      - literal指定を実装
      - ...に対応する
      - ドット対(.)に対応する
      - ベクタに対応する
      - wildcard(_)に対応する
        - _がリテラルとして指定された場合に対応する
      - varbatim( (<ellipsis> <template>) )に対応する
      - カスタムellipsisを実装

  - syntax-case用の関数を追加
    - identifier?
    - free-identifier=?: Syntax.isFreeIdentifierEqual
    - bound-identifier=?: Syntax.isBoundIdentifierEqual
    - datum->syntax: Syntax.datumToSyntax
    - syntax->datum: SyntaxObject#strip
    - generate-temporaries
    - identifier-syntax
    - with-syntax
    - make-variable-transformer (set!できるやつ)
    - #'等に対応
      - syntax #' quasisyntax #` unsyntax #, unsyntax-splicing #,@

o その他
  - syntax-rulesを実装
    - R7RSだとellipsisが指定できるので実装が必要
  - 構文を追加
    - let-syntax (macroでletrec-syntaxに変換？)
    - letrec-syntax (core)
    - syntax-error
  - case, condを書き直す
  o genVarを避けることはできないか？(原理的に衝突しないようにしたい)

o orrを実装する
  - define-syntax (syntax)
  - syntax-case (syntax)
  - syntax (syntax)

## 実行手順(tmp)

rakeするとa.scmが実行される。

----

## 2017/06/17

### 久々 18:14

パターンマッチをやるところからか。

## 2017/03/23

### log 03:00

    ## TODO

    + orr, swap!を削除
    + letを削除
    + internal defineのテストが通ってしまっているので、現行の処理を削除

    ## 実装ステップ

    o 新エクスパンダを組み込む
      + その上で既存のテストが通るようにする

    o 気になること
      - menvを参照している箇所がない
        - letrec-syntaxとかで使う？？


## 2017/03/21

### lambda 13:24

paramSpecがSOになることはあるか？

    (define-syntax foo
      (lambda (x)
        (syntax-case x ()
          ((_ ps)
           #'((lambda ps (list . ps)) 1 2)))))

    (write
    (foo (a b))
    )

こういうの考えると、ありそう。

## 2017/03/18

### label 23:58

- lambda
  - paramNameごとに
    - LabelとBindingを作成し、newEnvにセット
    - bodySoにaddSubstする(paramSo, label, bodySo)
- define x expr
  - Labelとbindingを作成し、newEnvにセット
  - 



## 2017/03/13

### うーん 22:10

全部の要素を配列に入れるのはさすがに無駄か？

env触ってる箇所：

- (_exp var) -> env.bindingOfId(var)
- (_exp (id x)) -> env.bindingOfId(id)
 
この二箇所しかないのか。

- getLabelでidが見つからなかったとき、
  なんらかのLabelを返すようにする
  - bindingOfIdは、getLabelがグローバルを見つけたら
    なんらかのBindingを返すようにする
    - Bindingはtypeとvalueの組
      typeはlexicalかglobalとかでいいと思うが

あーあとgvarを定義したときもこれをしないといけないのか。

###  16:16

とりあえずsyntax.jsでBiwaScheme.SyntaxEnvというグローバル変数を定義するようにしてみた。

### InitialEnvにglobalなものを足す 14:12

define_libfunc, define_syntaxに手を入れればいいかな？

- define_libfunc
  BiwaScheme.CoreEnv[fname] = f;
- define_syntax
  BiwaScheme.CoreEnv[sname] = s;

### エラー 12:12

Error: undefined identifier: print []
    at klass.getLabel ((biwa)src/system/syntax.js:66:11)
    at klass.bindingOfId ((biwa)src/system/syntax.js:325:31)
    at Object._exp ((biwa)src/system/syntax.js:526:27)
    at Object.expand ((biwa)src/system/syntax.js:501:21)
    at klass.resume ((biwa)src/system/interpreter.js:441:38)

場所は_exp

この時点でグローバル変数は見えていないといけないっぽい
macro/lexical/coreのどれか？
- 構文
  - macroとして登録
- 値
  - lexical、でいいのかな？

###  12:12

o 新エクスパンダを組み込む
  - その上で既存のテストが通るようにする

### ブランチ 01:38

hygenic-macroを0.7.xブランチにrebaseできるか確認。コンフリクトなし。
pushはどうしようかなぁ。とりあえずtmp-hygenic-macroというブランチを作った。

## 2017/03/10

### 新エクスパンダ 21:07

既存の構文を取り込む必要がある...けど、printはそういえば構文ではないな。

エラーが出てるのはどこか。

Error: undefined identifier: print []
    at klass.getLabel (/Users/yhara/Dropbox/proj/biwascheme/release/node_biwascheme.js:1710:11)
    at klass.bindingOfId (/Users/yhara/Dropbox/proj/biwascheme/release/node_biwascheme.js:1969:31)
    at Object._exp (/Users/yhara/Dropbox/proj/biwascheme/release/node_biwascheme.js:2170:27)
    at Object.expand (/Users/yhara/Dropbox/proj/biwascheme/release/node_biwascheme.js:2145:21)

###  19:47

実装ステップを書いた。
最初のステップはこれ

> o 新エクスパンダを組み込む
>   - その上で既存のテストが通るようにする
