# lazy

## 2016/05/01

### biwaschemeでどのように実装するか？ 21:57

わかったことは、「2つのpromiseを同時に更新する必要がある」ということなんだよね。なのでboxを共有させるというのはまあやりやすい方法ではある。

ただもう少し整理したいなぁ。

- promiseは以下のいずれか
  - eager promise == doneなpromise
    - 既に値が計算済みのpromise。
  - lazy promise
    - 「promiseを返すサンク」を持っているpromise。

理解が難しかった理由が見えてきた気がする。「promiseはこういうものであると説明されているもの」と、「実際に実装されているpromiseの中身」が一致しないからなんだな。

- promiseはこういうものであると説明されているもの
  - promiseはサンクと、結果を持つ
- 実際の(参照)実装
  - 計算済みのpromiseには値だけが入っていてサンクはない
  - 未計算のpromiseにはサンクだけが入っていて値はない
  - 未計算のpromiseが計算済みpromiseに変化するときはどうなるんだっけ
    - boxにフラグと値をコピーしてくるのか。

promiseにthunkとvalueを持たせるのはわかりやすいけど、「2つのpromiseを同時に更新したい」という要件が満たせないんだよな。

同時に更新、とは？
- old promise: ( (done . value) )
  new promise: ( ^  )
  - こうなってる。
  - doneがtrueのときはそれ以上更新されないから大丈夫
  - doneがfalseのとき
    - 続いてold promise(new promiseでもあるけど)のforceが行われる。
    - その結果としてboxの中身が書き換わる。
      #t . valueになるか、#f . thunkになるかのどちらか。

こう考えると、box方式以外の実装はなかなか思いつかないな…。無理にthunk + value方式に寄せても無駄が増えるだけだし。

### picrinのバグ 15:28

; 2. picrinのforceは (if (not (promise-done? promise)) の行がなく
; 常にpromise-update!をやるようになっている。
; このためreentrancy test 3に通らないはず -> やっぱり

もう一つ、

; 1. picrinのforceはrecordベースで実装されていてboxがないため、
; new promiseを参照していたとき結果が更新されないのでは？

これを考える。

最初、以下のようにdelayを二重にしてみたけど、こうじゃないんだな。これだと「Promiseを値としてもつPromise」ができるだけで連鎖評価にならない。

  (define p (delay (delay (+ 1 2))))
  (print (force p))

「サンクを評価したらpromiseだった」というのが肝なんだよね。というか、連鎖評価が起こるのは、promiseがlazy promise、つまりlazyで作ったpromiseだった場合のみなのか。lazyの引数は「promiseを返す式」だと決められているので、サンクを評価するとpromiseになることが保証されている(そうでない場合はエラー)。

そうか、lazyの定義自体から2つのpromiseが存在しているのか。引数の式を評価したときにできるnew promiseと、lazy自体が作るold promise。

lazyは「promiseを評価するpromiseを作る」という意味だ。old promiseをforceするとnew promiseがforceされる。一見意味不明だけど、
  - 「ストリームの先頭を見て結果のストリームを作る」という作業自体を遅延しないといけないのでdelayを付ける
  - ストリームをforceしたときは先頭を開ける必要があるのでforceを付ける
という理由で(delay (forceというイディオムがあり、これを効率化したい。

あー、だから、new promiseの値＝＝old promiseなのか。(reentrantされない限り)
こうしたほうがわかりやすいかな。

        (let ((promise* ((promise-value promise))))
          (if (promise-done? promise)
            (promise-value promise)
            (begin
              (promise-update! promise* promise)
              (force promise))))


## 2016/04/29

### 理解したぞ 04:03

(force p)はプロミスpが表す計算を実行し、その結果をpの値としてキャッシュするのでした。ところが下記の例のように、pの計算の途中で(force p)が呼ばれた場合はどうなるでしょうか？特に内側の(force p)と外側の(force p)で計算の結果が異なる値になった場合、どちらの値をキャッシュすればよいのでしょうか？

Schemeではこのようなときは、先に計算が終わった方、つまり内側の(force p)の計算結果が優先されることになっています。最初に計算結果が出た時点でpの値が固定されるということですね。なので下の例では、(print (force p))の「pの計算」自体は10という結果になるのですが、その前に「pの値は0だよ」という計算結果が出ているので、(force p)の返り値としては0が返ります。

これを実現しているのが例の(if (not (promise-done? promise)) というくだりで、promiseの計算中に自分自身の結果が出てしまっていたら、
  TODO: 出てしまっていたらどうする？どうなる？
  => 「そこで計算を打ち切り、自分自身の値を返す」


### ,/55/reent.scm 04:03

(define-values (get-count p)
  (let ((count 5))
    (define (get-count) count)
    (define p (delay (if (<= count 0)
                         count
                         (begin (set! count (- count 1))
                                (force p)
                                (set! count (+ count 2))
                                count))))
    (values get-count p)))

(print (get-count))
; この時点ではpは何もされていないので、countは初期値5のまま。

(print (force p))
; ここでpをforceする。(if ...以下の評価が始まる。
;   countを-1する。4になる。
;   ここでpをforceする。え、いままさに評価中なんだけど...。
;   でも評価が終わったわけではないので、pはdoneになっていない。よって
;   (if...以下の評価が始まる。
;     countを-1する。3になる。
;     ...
;     これを繰り返すと
;     countを-1する。0になる。
;     ここでpをforceすると、ifの値が0になる。この0がpの値にもなる。
;     ...のだが、話はまだ終らない。forceの実行をbeginで待ってるやつが
;     いるんだよね。その待ってるやつはcountを+2するので2になる。
;     で、続いて+2,+2,+2,+2で最終的に10が、最初の(force p)の結果になりそう
;     な気がするが、そうじゃないんだよね？
;     これが例の(if (not (promise-done? か。
;

(print (get-count) ) ; =>   10
; 最後にcountが10になっていることを確認。


### boxを捨てる？ 03:41

>   old = ( (done1 . value1) )
>   new = ( (done2 . value2) )
>   が、
>   old = ( (done2 . value2) )
>   new = ( ^                )
>   になる。newのboxは捨てられる。

単に捨てるだけなら#fでも入れとけばいいので、「boxが同じになる」ことが重要なのかも？つまり片方を更新したらもう片方も更新されるということ。

### reentrancy 01:30

そろそろ例のやつ読むか...。

```
;=========================================================================
; Reentrancy test 3: due to John Shutt

(define q
  (let ((count 5))
    (define (get-count) count)
    (define p (delay (if (<= count 0)
                         count
                         (begin (set! count (- count 1))
                                (force p)
                                (set! count (+ count 2))
                                count))))
    (list get-count p)))
(define get-count (car q))
(define p (cadr q))

(get-count)  ; =>   5
(force p)    ; =>   0
(get-count)  ; =>   10
```


### chibi-scheme 00:57

https://github.com/ashinn/chibi-scheme/blob/3dcac282ad76ea0e845d340bd2bdcea03d80e73c/lib/scheme/lazy.sld

こっちだとmake-promise xは(delay x)という定義になっている。面白いな。
それだとmake-promiseがdelayと別に用意してある意味がないけど...。

promise?を見ると、promiseはpairとして実装されてるのか。recordではないんだ。

https://github.com/ashinn/chibi-scheme/blob/1ec9d578d0a2b8f6bfe53d223b1641612ab75b83/lib/init-7.scm#L308
delay-forceはここ。erってことはexplicit renamingマクロか？

https://github.com/ashinn/chibi-scheme/blob/1ec9d578d0a2b8f6bfe53d223b1641612ab75b83/lib/init-7.scm#L1069
forceはここ。

promiseの定義は(list (cons done? proc))なのか。

promise-update!という関数が定義されている。
  (define (promise-update! new old)
    (set-car! (car old) (promise-done? new))
    (set-cdr! (car old) (promise-value new))
    (set-car! new (car old)))

  old = ( (done1 . value1) )
  new = ( (done2 . value2) )
  が、
  old = ( (done2 . value2) )
  new = ( ^                )
  になる。newのboxは捨てられる。


  (define (force promise)
    doneだったらvalueを返す
    doneでなければ、value(thunk)を評価しpromise*を得る
    thunkの評価によりpromiseがdoneになった場合を除き、
      promise*の中身をpromiseにコピーする。
    コピーした中身をもとに(force promise)する。

        (let ((promise* ((promise-value promise))))
          (if (not (promise-done? promise))
            (promise-update! promise* promise))
          (force promise))))))

あー、「promise*の中身をpromiseにコピーする」っていうことは、promise*はもう
破棄したいんだな。..., いや、わかったような気がしたけどわからないな。

### picrinの実装 00:36

https://github.com/picrin-scheme/picrin/blob/master/contrib%2F20.r7rs%2Fscheme%2Flazy.scm

recordベースで、Schemeレベルで実装してある。まあconsで実現できるんだからrecordなら余裕か。

しかしこれはpromise自体がdoneとvalueを持ってる実装だね。

make-promise%と%を付けてるのは、make-promiseは引数チェックするようにしたいからか。
あ、こう見るとmake-promiseはeagerそのものなのか。確かに引数が式でなく値だから、すでに計算が終わっていると考えられるのか。

  (delay-force promise-expr)は、doneでないpromiseを生成する
  == (make-promise% #f (lambda () promise-expr))

  (delay expr)は
       (delay-force (make-promise% #t expr))

で、問題のforce。

  (define (force promise)
    doneならvalueを返す
    doneでなければ：
      value(サンク)を評価しnew-promiseを得る
      done?とvalueをnew-promiseからコピー
      (force promise)

あれ、new-promiseのboxを破壊する処理がない。まあrecordにはboxに相当するものが
ないんだけど...。

          (set-promise-done!  promise (promise-done? new-promise))
          (set-promise-value! promise (promise-value new-promise))
          (force promise))))

あと、必ずコピーを行ってるんだな。srfi-45だと、サンク実行中にpromiseがdoneになった場合はコピーを行っていない。これって性能のためだけっていうこと？

### トランポリンって結局何なんだ 00:08

Promiseのガワを再利用する、ということは、「絶対使われないとわかっているpromise」が存在するということなのかな？

(lazy promise-exp)
=~ (delay (force promise-exp))

r7rsを読むと、delay-forceは(delay (forceと似てるが効率がよいことが保証される
という話になっている。つまり(delay (forceは非効率な可能性がある。


## 2016/04/28

###  14:04

(define (ones)
  (delay (cons 1 . (ones))))

このケースって効率よく実行されるんだろうか？

### 簡単なケースで考える 03:08

(define s (delay (+ 1 2)))
(force s)
(force s)
というプログラムを考える。足し算を行うプロミスを作りそれをforceする。

delayはlazyに置き換えられるから、
(define s (lazy (eager (+ 1 2))))
という定義になる。

s ---( ('lazy . (lambda () (eager (+ 1 2)))) )

forceの定義を文章で書いてみる。
  - (force promise)
  - promiseのtypeがeagerの場合は、promiseのvalueを返す
  - promiseのtypeがlazyの場合：
    - thunkを実行してpromise*を得る
    - (再入を考えない場合)
      promiseのtype, valueをpromise*からコピーする
      promise*のboxをpromiseのboxで上書きする(なぜ？？)
      - この結果、promiseとpromise*は別のオブジェクトだがboxは共有した
        状態になる。
      - promise*のもともとのboxは破棄される(これには意味がある？ない？)
      - promise*自体はすぐGCされるんじゃないのか？boxを差し替える
        必要があるか？
        - 一応、promise-exprが返り値をグローバル変数にセットする...みたいな
          ことをすれば、GCさせないことはできる
    - promiseをforceする。このpromiseは中身はpromise*からコピーした
      ものなので、thunkの実行結果をforceするというのが本意

### lazyとdelayの関係 03:11

(eager x) == 計算済みのプロミスを作る
(lazy promise-exp) == まだ計算済みでないプロミスを作る？

(lazy promise-exp)は、(delay (force promise-exp))に相当する。うーむ。

(delay exp)は(lazy (eager exp))という定義。参照実装ではlazyの方がprimitiveなんだよな。
delayはR5RSではプロミスをつくる構文だった。

(delay exp) == (delay (force (eager exp))) とかんがえられる？？
あー、delayの引数はlazyと違ってpromiseを返さない式でもいいのか。
(delay exp) == (lazy (eager exp)) というのは、expをpromise-expにするために
eagerを使っているとも考えられる。かな？

lazyがなぜpromise-expをとるか、というのは、forceの定義を見れば分かるだろうか？
まあ(delay (forceを効率化したかったので、引数はforceできるもの==promise-exp
に限る、という説明でもいいのかもだが。

> - consセルを書き換えるだけでは、Promiseがlazyからeagerに変わったことを
>   表現できない、とか？

昨日書いたやつだけど、Promiseがlazyからeagerに変わるというのは全くの正常系なんだな。

### トランポリン 02:54

    type Promise a = lazy (Promise a) | eager a

Ruby的に考えると、Promise = Struct.new(:proc, :value)なんだよな。
forceするとvalueにprocの実行結果がキャッシュされるという。

上の型はHaskell風だけど、実際にはlazyだったやつを無理やりeagerに
差し替えたりするからな。

「forceするとvalueにprocの実行結果がキャッシュされる」まではいいとして、
参照実装だとそのあとprocへの参照を切るんだよな。わざとなのかどうなのか。

ともかく、eager aは「すでに計算済みのやつ」を表してると思えばいいのかな？

### キャッシュ 00:27

デフォルトでキャッシュされるのって嬉しいんだろうか。

(define (click-times)
  (delay (begin
           (wait-for "#body" "click")
           (cons (current-time) (click-times)))))

例えば上のようにすると「bodyをクリックした時刻の列」を表すストリームが
できるけど...、うーん、まあ、そういうものだと思えばいいのかな。

一方で巨大なファイルを先頭から読むみたいなときは、「先頭」をグローバル変数に
代入したりしないよう気をつける必要がありそう。

### srfi-45 test cases(2)  00:06

; Memoization test 4: Stream memoization 
stream-dropという関数を定義する。
onesという無限ストリームを定義する。
  1が続いていくだけだが、displayを入れてある。
(force (stream-drop s 4))をするとどうなる？
同じsに対して二階やっても結果がキャッシュされるということか。これは
不思議だなぁ。

(ones)はPromiseを生成する。これがs。
sのforce結果は(1 . #<新しいPromise s2>)。

(stream-drop s 4)はPromiseを生成する。
それをforceすると：
  (force (if (zero?... と同じと考えると、
  (force (stream-drop (cdr (force s)) 3))
  (force (stream-drop s2 3))
  (force #<Promise>)
  (force (if (zero? ...
  (force (stream-drop (cdr (force s2)) 2)
  (force (stream-drop s3 2))
  (force #<Prmise>)
  ...
  (force (stream-drop s5 0))
  (force #<Promise>)
  (force (if (zero? ...
  (force s5)  ;=> (1 . s6)

となる。で、もう一度(stream-drop s 4)をやると：
  (force (if zero? ...
  (force (stream-drop (cdr (force s)) 3))
  ここでsは一度forceしているので、計算はスキップされる
  (force (stream-drop (cdr (1 . s2)) 3))

なるほどなあ。Promise自体がキャッシュを持つからこうなるのか。

## 2016/04/26

### srfi-40 22:46

- stream-delayがdelay相当だが、stream-forceはない(stream-xx側で自動的に行われる)
  - まあ確かにstreamをforceするって何じゃいという感じはある

- srfi-40の参照実装はsrfi-45に言及している
  - srfi-40は2003/02提案
  - srfi-45は2003/09提案で、40より先にfinalになっている
- srfi-41は2007年提案
  http://compassoftime.blogspot.jp/2014/12/srfi-41.html
  http://fixedpoint.jp/2008/01/29/srfi-41.html
  同じ著者なのかぁ。

> SRFI 41 は SRFI 40 に比べて
> 
> stream-lambda などのベーシックな構成要素から便利な手続きをより多く提供している
> Examples の節にストリームを使った典型的な具体例がある
> Pitfalls の節にストリームの実装が陥りがちな失敗が明記されている
> という内容になっています。議論を重ねてより良い仕様を導くという目的が達せられているといえます。
> 
> (それにしても deprecated になった SRFI はこれが初めてなのではないでしょうか?)

  - Pitfalls
    - named letはだめ、stream-letでないと

  - srfi-40でdelayをexposeしたのは間違いだった、と書いてある
    srfi-41ではstream-lambdaが基本で、これがlazyを隠す

### 効率 22:34

- odd streamでは効率上の問題はないんだろうか？
  - まあやってみればいいか。

### http://srfi.schemers.org/srfi-40/srfi-40.html 21:51

(delay (force x))についてコメントがあった。
これをforceすると結果はxになるんだけど、計算がキャッシュされるという違いがある、ということ。

ODD, EVEN, EASY: (delay (forceをマクロで隠すと楽、という話
(delay (forceが要るとかいうのは実装上の都合なんだからユーザに見せるのはダサい、という主張
  - Promiseのことを知らずに、Streamのライブラリとしてだけ考えた場合の話か。ふーむ

- 「(delay (forceというイディオムがある」という話

- even streamがあればodd streamを実装することはできるよ、という余談
- Streamの要素はアクセスされたときに評価されるべきで、作られたときに評価されちゃうのはlazyとは
  言えないよね、という主張
- 効率について
  - stream-filterで3000000回ループしようとすると、途中を全部キャッシュしてしまう

### srfi-45 test cases 21:41

- ; Memoization test 1:
  - delayの副作用が一回しか表示されないよ、という例。わかる
- 2
  - 式の中にあってもだよ、という例。
- 3
  - まずrをPromiseとする
  - rをlazyで包む
    - (lazy r) がもうよくわからない...。
    - (delay (force r)) とだいたい同じなはずだから、
      「rをあとでforceする」と読めばいいのかな。
  - ともかくlazyで包んでもメモ化されるよ、という例。


### srfi-45 21:34

型が書いてあった。

    type Promise a = lazy (Promise a) | eager a

    eager: a -> Promise a
    lazy: Promise a -> Promise a
    delay: aを返す式 -> Promise a
    force: Promise a -> a

### http://d.hatena.ne.jp/propella/searchdiary?word=%2A%5Blazy%5D 21:10

(5)にて。
"言い換えると、フィルターの振る舞いでは、テストに引っかかるまで次々と CDR を force して行く必要があります"

一瞬納得したような気がしたけど、これは単にforceを移動しただけじゃないのか。

### 20:59

ややこしいのでサンクがPromiseを書き換えない場合だけ考えてみる。
- この場合、content_はつねにcontentと同じもの

(define (force promise)
  (let1 content (unbox promise)
    (case (car content)
      ; eager Promiseの場合は値を返すだけ
      ((eager) (cdr content))
      ; lazy Promiseの場合
      ((lazy)  (let1 promise* (cdr content)       
                 (begin (set-car! content (car (unbox promise*)))
                        (set-cdr! content (cdr (unbox promise*)))
                        (set-box! promise* content)))
                 (force promise))))))

     promise:
       (
        ('lazy . サンク)   ; <-- content
       )

     promise*(サンクの実行結果) : 
       (  
        (<2> . <3>)
       )

     トランポリン処理後のpromise:
       (
        (<2> . <3>)    ; <-- content
       )
     トランポリン処理後のpromise*:
       (
        (<2> . <3>)    ; <-- content
       )

このあと再度(force promise)が呼ばれる。

- これによって何を達成しているのか？
  - もともとやりたかったこと：(force (delay (force (delayみたいに
    なったとき、delayの意味論としてxxxx

- これでどうしてメモ化が実現されるのかしら
  - Promiseの中身を破壊するみたいなことをしてるが、そのときメモ化はどうなるんだろう

### srfi-45 20:26

Promiseは以下のいずれか(content)をboxingしたもの
  - ('lazy . サンク)  サンクはPromiseを返さなくてはならない
  - ('eager . 値)

; eager Promiseを生成する
(eager x)  == (box (cons 'eager x))
; lazy Promiseを生成する
(lazy exp) == (box (cons 'lazy (lambda () exp)))

; lazy Promiseを返す
; それを評価するとeager Promiseが返る
(delay exp) == (lazy (eager exp))
  == (box (cons 'lazy (lambda () (eager exp))))

(define (force promise)
  (let1 content (unbox promise)
    (case (car content)
      ; eager Promiseの場合は値を返すだけ
      ((eager) (cdr content))
      ; lazy Promiseの場合
      ((lazy)  (let* ((promise* ((cdr content)))        
                      (content_  (unbox promise)))                ; *
                 (unless (eq? (car content_) 'eager)                 ; *
                   (begin (set-car! content_ (car (unbox promise*)))
                          (set-cdr! content_ (cdr (unbox promise*)))
                          (set-box! promise* content_)))
                 (force promise))))))

- なぜboxingが必要か
  - consセルを書き換えるだけでは、Promiseがlazyからeagerに変わったことを
    表現できない、とか？
- lazy Promiseの場合、無限ループにならないか？

     promise:
       (
        ('lazy . サンク)   ; <-- content
       )

     サンク実行後のpromise:
       (
        (? . ?)  ; <-- content_
       )
     
     promise*(サンクの実行結果) : 
       (  
        (<2> . <3>)
       )

     トランポリン処理後のpromise:
       (
        (<2> . <3>)  ; <-- content_
       )
     トランポリン処理後のpromise*:
       (
        (<2> . <3>)  ; <-- content_
       )

     - promise* == サンクの実行結果
     - content_ == 基本はcontentと同じだが、サンクの実行中にpromiseの
         中身が差し替えられた場合はそれを指す
     - (サンクがもとのPromiseの中身をeagerに変えた場合を除き)トランポリン処理を行う。
       - content_のcarとcdrを、promise*の中身のcarとcdrに入れ替える
       - promise*の中身をcontent_で入れ替える
         
       


## 2016/04/09

### r7rs p.19 01:42

(head (tail (tail (stream-filter odd? integers))))
(head (tail (tail (delay-force ...)
=> (head (tail (cdr (force (delay-force ...)
=> (head (cdr (force (cdr (force (delay-force ...)
=> (car (force (cdr (force (cdr (force (delay-force ...)

## 2016/04/08

###  14:48

(delay-force exp)は、以下と同じ
(lazy exp) は、以下と同じ
     (box (cons 'lazy (lambda () exp))))))

(delay exp) は、以下と同じ
     (lazy (box (cons 'eager exp))))))

(define (force promise)
  (let ((content (unbox promise)))
    (case (car content)
      ((eager) (cdr content))
      ((lazy)  (let* ((promise* ((cdr content)))        
                      (content  (unbox promise)))                ; *
                 (when (eq? (car content) 'lazy)                 ; *
                     (begin (set-car! content (car (unbox promise*)))
                            (set-cdr! content (cdr (unbox promise*)))
                            (set-box! promise* content)))
                 (force promise))))))

## 2016/04/07

###  14:43

http://www.katch.ne.jp/~leque/translations/srfi-45/srfi-45j.html

; type Promise a = lazy (Promise a) | eager a 

(define-syntax lazy
  (syntax-rules ()
    ((lazy exp) 
     (box (cons 'lazy (lambda () exp))))))

(define-syntax delay
  (syntax-rules ()
    ((delay exp)
     (lazy (box (cons 'eager exp))))))

(define (force promise)
  (let ((content (unbox promise)))
    (case (car content)
      ((eager) (cdr content))
      ((lazy)  (let* ((promise* ((cdr content)))        
                      (content  (unbox promise)))                ; *
                 (when (eq? (car content) 'lazy)                 ; *
                     (begin (set-car! content (car (unbox promise*)))
                            (set-cdr! content (cdr (unbox promise*)))
                            (set-box! promise* content)))
                 (force promise))))))


###  02:01

(define (stream-filter p? s)
 (delay (force 
         (if (null? (force s)) (delay '())
          (let ((h (car (force s))) 
                (t (cdr (force s))))
           (if (p? h)
            (delay (cons h (stream-filter p? t)))
            (stream-filter p? t)))))))

(define (stream-filter p? s)
 (delay 
   (if (null? (force s))
    '()
    (let ((h (car (force s))) 
          (t (cdr (force s))))
     (if (p? h)
      (cons h (stream-filter p? t))
      (force (stream-filter p? t)))))))

(define (stream-filter p? s)
 (lambda ()
   (let1 x (s)
   (if (null? x)
    '()
    (let ((h (car x)) 
          (t (cdr x)))
     (if (p? h)
      (cons h (stream-filter p? t))
      ((stream-filter p? t))))))))

(define (list->stream ls)
  (if (null? ls)
    (lambda () '())
    (lambda () (cons (car ls) (list->stream (cdr ls))))))

## 2016/04/05

### delay, force 22:28

r7rs 4.2.5にある。

- syntax (delay expression)
- syntax (delay-force expression)
- (force promise)
- (promise? obj)
- (make-promise obj)
  
delay-forceは

  (delay-force 


