## http://ksmakoto.hatenadiary.com/entry/2016/03/06/174938

- Gaucheのstream-delayの項に
  > 原則として、ストリームを生成する関数はすべからく結果を stream-delayでラップすべきです
  とあるのはなぜか？
  - stream-consがそうなっていればいいだけなんじゃないの？
    => そうではない、という話が続くらしい
    (予想：delay-consを使わないとリークするから、という話？)

- 遅延プリミティブとして、delayをlambdaにほぼ置き換えただけのもので議論する
- oddとeven
  - SICP: odd
  - SRFI-40: even
- odd: Stream == (値 . Promise)
  - リストをcarとcdrに分ける、という操作はLispのイディオムだけど、
    odd streamを「carとcdrに分ける」と、cdrもforceされてしまう。
    結果として、carだけ取ったつもりなのにもう一つ値を読んでしまったりする
- even: consセル自体を遅延させる
  - その代わりcarだけ取るにもforceしないといけない
  - 「正しいymap1は(delay (force ...のようになる」
    - これじゃだめなのかな？
      (define (ymap1 f st)
        (if (ynull? st)
          ynull
          (ycons (f (ycar st))
                 (ymap1 f (ycdr st)))))
    - これだと「Streamをymapしたやつ」を作りたいだけなのに、
      最初のynull?のところでforceされちゃうのか。
    - じゃあこれでいい？
      (define (ymap1 f st)
        (delay
          (if (ynull? st)
            ynull
            (ycons (f (ycar st))
                   (ymap1 f (ycdr st))))))
    - これだとdelayが二重になっちゃうのか。
      だから(delay (force としないといけないのか。
  - しかしやっぱり(delay (forceってなんか腑に落ちない感じがある
    - ymap1はStream、つまりプロミスを返さないといけない
      そのプロミスはforceしたとき(値 . Stream)を返さないといけない
      (delay だけだと、force結果がPromiseになってしまう
    - それぞれのdelay, forceはいつ評価されるのか？
      (define (ymap1 f st)
        (delay (force  ; 1, 2
          (if (ynull? st)
            ynull  ; 3
            (ycons (f (ycar st))
                   (ymap1 f (ycdr st))))))
      - 1のdelay: ymap1したときに呼ばれる。Promiseを作る
        2のforce: map後のStreamを評価したときに呼ばれる。
          map後のStreamを評価するとどうなるか？
          forceは手続きなので、引数の評価が先になるのか。
            引数の評価＝stの先頭を見て、Promiseを作る
          しかし作ったPromiseはforceによってすぐ評価される。
          map後のStreamを評価する、ということは、「次の値」が入った
          コンスセルを生成する、ということなのでこれでよい
        

- PromiseでStreamを作ると、
    
