
;; 結果がキャッシュされる、というデモ
;(define p (delay (begin
;                   (print "forced")
;                   (+ 1 2))))
;(print (force p))
;(print (force p))


; ストリームを作る
; https://www.shido.info/lisp/scheme_lazy.html
;
; Stream = (obj . Promise[stream]) or '()
(define zcar car) ; Stream -> Object
(define (zcdr st) ; Stream -> Stream
  (force (cdr st)))

; 一見正しいが、これだとxと式からストリームを作ることができないので実際は微妙
;(define (zcons x st)
;  (cons x st))
(define-syntax zcons
  (syntax-rules ()
    ((_ x expr) (cons x (lazy expr)))))

(define (zfrom n) ; Integer -> Stream
  (zcons n (zfrom (+ n 1))))

(define (zmap f st) ; ('a -> 'b) -> Stream['a] -> Stream['b]
  (if (null? st)
    '()
    (zcons (f (zcar st))
           (zmap f (zcdr st)))))

(define (zmapn f . sts) ; ('a... -> 'b...) -> List[Stream['a]] -> List[Stream['b]]
  (if (memq '() sts)
    '()
    (zcons (apply f (map zcar sts))
           (apply zmapn f (map zcdr sts)))))

(define (zfilter pred st) ; ('a -> Bool) -> Stream['a] -> Stream['a]
  (if (null? st)
    '()
    (if (pred (zcar st))
      (zcons (zcar st) (zfilter pred (zcdr st)))
      (zfilter pred (zcdr st)))))

(define (zhead st n) ; Stream -> Integer -> List[Integer]
  (if (= n 0)
    '()
    (cons (zcar st) (zhead (zcdr st) (- n 1)))))

(define (znth st n)
  (if (= n 0)
    (zcar st)
    (znth (zcdr st) (- n 1))))

;(define (stream-filter pred st) ; ('a -> Bool) -> Stream -> Stream
;  (if (null? st)
;    kk

;(print (zhead (zmap (lambda (x) (* x 2)) (zfrom 3)) 9))
;(print (zhead (zfilter odd? (zfrom 3)) 9))

;; ストリームでフィボナッチ

(define zfib
  (zcons 1 (zcons 1 (zmapn + zfib (zcdr zfib)))))

;(define zfib2
;  (zcons 1 (zcons 1 ( ...zmapnなしでやろうと思うと、結局zmapnの定義をここに展開することになる

; zfib == (1 . <Promise>)
;                 \_ (1 . <Promise>)
;                             \_ ((zmapn + zfib (zcdr zib)) . <Promise>)

;(print (zhead zfib 9))
;(print (znth zfib 10000))  ; メモ化されるので一瞬で終わる

;; 無限ループ
(define loop
  (delay (force loop)))

(force loop)

