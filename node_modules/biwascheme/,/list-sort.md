# list-sort with comparator

- ヒープソート
  pros: 内部ソート
  cons: 安定ソートでない

- マージソート
  pros: 安定ソート
  pros: 最悪時間が良い
  cons: 内部ソートでない

## 2016/11/16
### log 11:53

    var heapSort = function(ary, proc, state) {
      var k = (ary.length - 2) / 2;

      var i = k;
      var v = ary[k];
      while(1) {
        var j = 2*i+1;
        if(j > r) break;
        if(j != r) {
          return new Call(proc, [ary[j], ary[j+1]], function(ar) {
            return heapSort(ary, proc, [1, j]);
            TODO: 「右の方が大きい」ということを分かった上で続きをやる

            ソート処理に入るor戻ってくるポイントは数個しかないので、
            引数で情報を渡してやればよいはず
              switchとgotoになる気がする

            再帰が深くなりすぎないように注意する必要がある？
            Tail callにしとけば大丈夫かな？

          };
        }
      }
    };
    
    //(vector-sort! proc vector)    procedure 
    define_libfunc("vector-sort!", 1, 2, function(ar){
      var proc, vector;
      if(ar[1]){
        assert_procedure(ar[0]);
        assert_vector(ar[1]);
        return heapSort(ar[1], ar[0], [0]);
      }
      else {
        assert_vector(ar[0]);
        ar[0].sort(compareFn);
        return BiwaScheme.undef;
      }
    });

### んー 02:53

routeだけじゃだめか。このルートは完了した・完了してないみたいな情報が要る？
そうでないとmerge_が完了したあと、同じところをもっかいソートしに行ってしまう気がする？

    C  D E  F
      A   B

こうなってたとき

  - route == [0, 0] から始まる
  - 長さが1、末尾が0なのでroute = [0, 1]
  - 長さが1、末尾が1なのでマージを行う
  - CDをマージしたものができるのでaryに書き戻す
    route = [0], up = true
  - len >= 2だがupが真
    route = [1], up = false
  - len >= 2なのでroute = [1, 0]
  - E。len == 1 なので route = [1, 1]
    F。EFをマージ。aryに書き戻す
    route = [1], up = true
  - len >= 2だがupが真
    CD, EFをマージ。aryに書き戻す
    ソート完了。

配列が長さ2のとき
  - ary = [a, b], route = [0]

###  02:32

        return mergeSort(ar[1], ar[0], [0]);

    // Callを返すか、contを呼んだ結果を返す
    var merge_ = function(ary1, ary2, proc, ret, i, j, cont) {
      var len1 = ary1.length, len2 = ary2.length;
      if (i < len1 && j < len2) {
        return new Call(proc, [ary2[j], ary1[i]], function(lt) {
          if (lt) {
            ret.push(ary2[j]); j+=1;
          }
          else {
            ret.push(ary1[i]); i+=1;
          }
          return merge_(ary1, ary2, proc, ret, i, j, cont);
        });
      }
      else {
        while (i < len1) { ret.push(ary1[i]); i+=1; }
        while (j < len2) { ret.push(ary2[j]); j+=1; }
        return cont(ret)
      }
    };

    var mergeSort_ = function(ary, proc, route, up) {
      while(true) {
        var start = 0, len = ary.length;
        _.each(route, function(lr){
          len /= 2; 
          if (lr == 1) start += len;
        })

        if (len >= 2 && !up) {
          route.push(0); continue;
        }
        else if (route[route.length-1] == 0) {
          route[route.length-1] = 1; up = false; continue;
        }

        var ary1 = ary.slice(start, start+len/2),
            ary2 = ary.slice(start+len/2, start+len-1);
        return merge_(ary1, ary2, proc, [], 0, 0, function(ret) {
          for (var i = 0; i < ret.length; i++) {
            ary[start + i] = ret[i];
          }

          route.pop()
          if (route.length == 0) {
            return ary;
          }
          else {
            return mergeSort_(ary, proc, route, true);
          }
        });
      }
    };

    var mergeSort = function(ary, proc) {
      if (ary.length <= 1) return ary;

      var route = [], l = ary.length;
      while (l >= 2){ l /= 2; route.push(0) }

      return mergeSort_(ary, proc, route, false);
    };


### だめだ 02:31

ヒープソート

### んー 02:17

マージ部分は良さそうな感じになったが。

- 今何をやっているのか？というのはどう整理できるか。
  - 左なのか右なのか、という情報が必要
    - 左の場合、終わったら右のソートに進む
    - 右の場合、終わったら左右のマージに進む

    - (一応、範囲の始点が2の乗数かとかで分かるかもだが)

- 開始はどうするか
  - 一番左の範囲が対象になる

## 2016/11/15

### CPS 23:37

分割を考える。
最初の二分割はこう。
  0 ... len >> 1  |  len >> 1 ... len-1
もう二分割するとこうなる。
  0...len >>2 | len>>2...len>>1 | len>>1...(len>>1 + len>>2) | (略)

二分木になるから、左右どちらを選んだのかのルートを持ってればよさそう？

### マージソートが安定にならない 23:21

なぜだろう。

ん、必ず逆順になってるっぽい。

そうか、a < b じゃなく b > a をしないと安定にならないのか。

### マージソートをCPSにするには？ 23:05

なんか考えればできそうな気がしてきた。

- リストの長さが9のとき、
  1. リストを4と5に分ける
  2a. リスト4のソート
    1. リストを2-2に分ける
    2a. リスト2のソート
    ...
  2b. リスト5のソート
  3. ソートされた4と5をマージする

compによる中断は、マージフェーズでのみ起こる。
  
パラメータを考える。

- いま、全体のどの範囲をソート中なのか(終わったあと何をするのか)


### ヒープソート 22:22

CPSにはできそうな気がしてきた(アセンブラっぽく書く)けど、これ
安定ソートじゃないのか...

## 2016/11/15

###  02:06

だめだ、ヒープソートでもCPSにするのつらすぎる、、。

ES6 generatorとか使えないだろうか？

## 2016/11/14

###  13:32

配列N[0]～N[length-1]に値が格納されている時（すなわちデータの数はlengthである）、k = (length - 2) / 2 、a = kとする。このN[k]が親ノードとなる。

j = 2 * k + 1とする。つまり、N[j]はN[k]の左側の子である。 もし、N[j + 1]にノードが存在するなら（つまり右側にも子があるなら）、N[k]とN[j]とN[j + 1]の値を比較する。
- N[k]が最大の時、a = a - 1 、 k = a とし、同様の操作を続ける。
- N[j]が最大の時、N[k]とN[j]の値を入れ替える。k = jとし、同様の操作を続ける。
- N[j + 1]が最大の時、N[k]とN[j + 1]の値を入れ替える。k = j + 1とし、同様の操作を続ける。

葉がない時（k = j または k = j + 1 としてもその下に子がない時）、a = a - 1 、 k = a とし、同様の操作を続ける。


a = 0 の時、同様の操作を行い、終了となる。

###  01:49

とりあえずruby版ができた。

けどこれ再帰なんだよな。CPS化するのがめんどいか。

ヒープソートとかどうだろう？
その場合二分木が要るのか。

###  01:38

クイックソートのつもりだったけど最悪計算量考えるとマージソートの方が良さそう。



