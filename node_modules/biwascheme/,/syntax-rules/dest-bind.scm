(import
 (scheme base)
 (scheme write)
 (scheme cxr)
 (picrin macro))

;(define-syntax destructuring-bind
;  (ir-macro-transformer
;   (lambda (form inject compare)
;     (let ((pattern (cadr form))
;	   (value   (caddr form))
;	   (body    (cdddr form)))
;       (cond ((null? pattern)
;	      `(begin ,@body))
;	     ((symbol? pattern)
;	      `(let ((,pattern ,value)) (begin ,@body)))
;	     ((pair? pattern)
;	      `(let ((evaluated ,value))
;		 (destructuring-bind ,(car pattern) (car evaluated)
;		   (destructuring-bind ,(cdr pattern) (cdr evaluated)
;		     ,@body)))))))))
;
;(destructuring-bind (a b . c) '((1 2) 3 4 5) (list a b c)) ; ok
;(destructuring-bind ((a b) . c) '((1 2) 3 4 5) (list a b c)) ; fail

(define-syntax destructuring-bind
  (syntax-rules ()
    ((_ (a . b) value body ...)
     (let ((evaluated value))
       (destructuring-bind a (car evaluated)
         (destructuring-bind b (cdr evaluated)
           body ...))))
    ((_ () value body ...)
     (begin body ...))
    ((_ sym value body ...)
     (let ((sym value))
       (begin body ...)))))

(destructuring-bind (a b . c) '((1 2) 3 4 5)
                    (write (list a b c)) (newline))
(destructuring-bind ((a b) . c) '((1 2) 3 4 5)
                    (write (list a b c)) (newline))
(write (macroexpand
  (destructuring-bind ((a b) . c) '((1 2) 3 4 5)
                      (write (list a b c)) (newline))
  ))

;(#<identifier user#let> ((#<identifier user#evaluated> '((1 2) 3 4 5)))
; (#<identifier user#destructuring-bind> (a b) 
;  (#<identifier user#car> #<identifier user#evaluated>)
;  (#<identifier user#destructuring-bind> c
;   (#<identifier user#cdr> #<identifier user#evaluated>)
;   (print (list a b c)))))
