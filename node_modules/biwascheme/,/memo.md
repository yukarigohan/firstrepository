# BiwaScheme

o 数について
  - [ ] number?等が壊れている
  - 複素数
    - finite?, infinite?, nan?
    - abs
    - sqrt
    - expt

- biwasで(define (f) (p 1) (sleep 1) (p 2)) とした場合に、待ってほしい

- #27 class="biwascheme"
  - yhara/#18 id="biwa-script" を閉じる

- ウェブサイトに注記を追加

o 0.7
  - package.jsonを直さないといけない
    (mainがいまのままになってるが、 release/node_biwascheme.jsの
     生成自体をやめる)
  - 

## Help Wanted

- ユニットテストをコマンドラインでやりたい
- ES2016を使うようにしたい

## syntax-rules

- syntax-rulesでlet-in-order, destructual-bindを書くことはできるか？

- Chibi: SC -> ER -> syntax-rules
- Picrin: make-identifier -> (SC, syntax-rules)

## 1.0.0について

- 新機能
  - syntax-rules
  - ライブラリ読み込み(script type="text/biwascheme")
    - type="text/biwascheme"が付いているときはR7RSモードにする
      - define-record-typeがR7RS仕様になる
  - multi interpreter
    (scriptタグが複数あるとき、名前空間を共有しない？)

----

## 2017/10/12

### sicp 16:14

- Interactive SICP https://github.com/sarabander/sicp-live
  BiwaScheme
  https://news.ycombinator.com/item?id=4860370

  - 元repo https://github.com/ldct/isicp
    こっちは自前のjs Scheme処理系を持っている

- gaucheの
  https://github.com/shirok/Gauche-compat-sicp/blob/master/compat/sicp.scm
  
- SICPを読むためにやっておくと便利かもしれないこと
  https://qiita.com/da1/items/02f7d2f157c7145d58f2

## 2017/08/12

### なるほど 04:04

,,@ というパターンがだめだったのだけど、これはR7RSでは許されてないかも。
R6RSではできるらしいけど。

###  04:01

gosh> ``(1 2 ,(3 ,'(4 5)))
`(1 2 ,(3 (4 5)))
gosh> ``(1 2 ,(3 ,@'(4 5)))
`(1 2 ,(3 4 5))

### ,,@ls 01:11

このケースだけ対応したらいい？

  `式
  = (quasiquote 式)
  = expand_qq(式, 1);

  `,式
  = `(unquote 式)
  = (quasiquote (unquote 式))
  => 式!

  ``,,式
  = ``(unquote (unquote 式))
  => `(unquote 式!)
  =  `,式!

  ``(,,式)
  ``((unquote (unquote 式)))
  => `((unquote 式!))

  ``(,,@式)
  ``((unquote (unquote-splicing リスト式)))
  => `((unquote リ ス ト 式!))


### うーむ 00:56

このケースがだめ。

    (let1 ls '(5 6)
      `(1 2 `(3 4 ,,@ls)))")


expand_qq(1)
;=> 1
; `1 == 1
expand_qq( (1 2) )
;=> (1 2)
; `(1 2) == (1 2)
expand_qq( ,x )
expand_qq( (unquote x) )
;=> "x"
; `,x == x
expand_qq( ,@x )
;=> これはエラー
expand_qq( (,@ab) )
;=> ("a" "b")


## 2017/08/11

### vector qq 23:20

    (let1 ls '(5 6)
      `#(1 2 `#(3 4 ,,@ls)))

- 1 expand_qq([1, 2, ....], )
  - 1 expand_qq(1)
  - 1 expand_qq(2)
  - 1 expand_qq( (quasiquote #(3 4 ,,@s))
    - 2 expand_qq( #(3 4 ,,@s)
      - 2 expand_qq(3)
      - 2 expand_qq(4)
      - 2 expand_qq( (unquote (unquote-splicing s))
        - (list 'unquote 
          - 1 expand_qq( (unquote-splicing s) )
            - 

## 2017/08/10

### vector qq 18:25

せっかくだしついでにやるか？

listはconsが使えるから、,@を見つけたところでappendにすればいいけど、
vectorの場合は先に,@があるか調べないといけないのか。
(あるいはぜんぶvector-appendにしてしまう、、)

  #(a b ,@c d)

  #(a b (unquote-splicing


### expand_qq 13:44

lvってなんで要るんだっけ。
R7RSよむ。

- quasiquoteがあるとlvが増える
  unquoteがあるとlvが減る
  最も外側のquasiquoteと同じlvのものだけ展開が起こる

### quasiquote 13:11

quasiquoteはListに対するinterpolationみたいなもの。

(define admin "Administrator")
(define users '("Taro" "Jiro"))

`("NewUser" ,admin ,@users)

 ("NewUser" "Administrator" "Taro" "Jiro")

quasiquote内にquasiquoteを書くとどうなるか。

 `(a b `(c d))
 ;=> (a b `(c d))
 ;=> (a b (quasiquote (c d)))

こうなるのか。

## 2017/07/21

### website 20:01

github.ioを使うようにしようかなあ。最近はmasterをサイトにできるし。

1. 現在の場所から0-6-xブランチを切る
1. 0-7-xをmasterにマージ(fast-forward？)する
1. github.ioをサイトにするよう設定する

これでいけるかな？

## 2017/07/15

### load 20:37

memo/eval.md

### bind 20:30

Function.prototype.bind (== Function#bind)

えーと、どうするんだっけ？

やりたいのは、
  new ctor(**args)
これは、

てか ,/ml132-js-new/ にあった。

## 2017/03/08

### memo/syntax_rules.md 09:01


## 2016/11/29

### タグのやつ 01:53

新形式＝R7RSモードにしようかと思ってたけど、それだと先になりすぎる(ライブラリが必要)
ので、importを書いたらR7RSモードってことにしようと思う。

そうすれば、新形式をすぐに実装できる。

## 2016/11/13

### sort 22:14


## 2016/10/05

### procedure? 23:02

> "Error: Invalid lambda: (lambda ()) []"

あーこれエラーメッセージをチェックしてるのか。微妙だな、、
とりあえずは消しておくか。エラーケースだし。

### (define a (+ 1 a))  21:46

undefを埋めるのやめたら、assign-globalがエラーを返すようになった。
(set! asdf 1)とかやったときに通っちゃうのを防ぐためか。


## 2016/10/02

### (define a (+ 1 a)) 03:35

なんかrefer-global aがundefを返している。

### puts 02:59

> BiwaScheme.Port.current_error.puts is not a function

- current_errorはbrowser/console.jsでセットされている
  BS.Port.CustomOutput

## 2016/10/01

### idの件(2) 22:07

こういうmainプログラムがあったとする。これはライブラリ(tetris block)をimportする。
  <script type="text/biwascheme">
  ; 厳密なR7RSプログラムはimport宣言から始まる。
  (import (scheme base) (tetris block))
  ...
  </script>

ライブラリ(tetris block)の定義は以下。さて、これをどこに置く？

  <script type="text/biwascheme">
  (define-library (tetris block)
    (export いろいろ)
    (import (scheme base))
    (begin
      ...
  </script>

- a) 同じHTMLファイル内に置く場合
  - 読み込み順序の問題がある
  - a) HTMLタグを前にしか書けないようにする？
  - b) mainを明示させる？
    - script type="text/biwascheme" data-main="true"
    - じゃないや、data-libraryが書いてなければmainとみなせばいいか。

- b) 単体のファイルにしたい場合
  こうかなぁ。
  <script type="text/biwascheme" src="tetris/block.scm"
    data-library="tetris block"></script>
  - 1. 最初にscript[type="text/biwascheme]を集める
  - 2. importされたらAjaxで取ってくる

- c) 単体のファイルかつ、静的にコンパイル？
  - 1. 最初にscript[type="text/biwascheme]を集める
  - 1. srcが書いてないものをmainとみなす
    - それぞれのimportを調べ、埋め込む？
    - ここまでやるならjsにしてしまったほうがいいかもだが

- load
  (load "tetris/block.scm")
  単にajaxする(ってかすでにあるのか。)


## 2016/09/15

###  02:52

- pr-23でBrowserInputが消えてる気がするので復活させる(一応、互換性のため..)

## 2016/09/13

### 6.2 Numbers 14:10

- 数学的な数
  - number >= complex number >= real number >= rational number >= integer
  - number? complex? real? rational? integer?
- Schemeがモデル化しようとしているもの
  - 
- Schemeの数の実装上の表現
- 数を記述するための記法

- Exactness
  - 上の階層関係とは直交 
  - 配列のindexとかはexactでないとおかしい
  - 複数の処理系がexactな処理のみで同じ結果を出したなら、それらは数学的に等しい
    inexactが混ざる場合はそうとは限らない
  - Rational#+とかはexactでないといけない。そうならない場合はエラーにするかinexactを返す
  - (exact関数以外は)基本、引数がinexactならinexact数を返すが、0倍のように
    exactだと証明できる場合はexactを返してもよい。

  
## 2016/08/05

### pr-23 18:58

Changes to be committed:

        modified:   demo/repl.html
        modified:   src/header.js
        modified:   src/library/extra_lib.js
        modified:   src/library/srfi.js
        modified:   src/library/webscheme_lib.js
        modified:   src/platforms/browser/console.js
        modified:   src/platforms/browser/release_initializer.js
        modified:   src/platforms/node/module_postamble.js
        modified:   src/system/compiler.js
        modified:   src/system/interpreter.js
        modified:   src/system/port.js
        modified:   website/js/biwascheme_terminal.js

Unmerged paths:
  (use "git add <file>..." to mark resolution)

        both modified:   bin/biwas
        both modified:   src/development_initializer.js
        both modified:   src/platforms/node/module_preamble.js

3ファイルがコンフリクト。

## 2016/05/07

### biwa-script 01:16

ライブラリは置いておいて、とりあえずid=biwa-scriptだけでも実装したいな。
minorをあんまり上げたくなかったんだけど、考えてみれば別に0.10.xでもいいし。

- idでいいのか？
  - 複数用意するときはclassでないと？
  - data-xxを使う？
  - idにするならbs-consoleもbiwa-consoleにしたいね


## 2014/03/11

### idの件(2) 14:57

提案手法： https://github.com/biwascheme/biwascheme/pull/27
  `<script class="biwascheme">...</script>`
  `<script class="biwascheme" src="...">`  この場合はtypeを書かないとJSと見なされるかな？

### idの件

- Move http://movelang.org/
  `<script type="text/move" module="bar">` -> bar
  `<script type="text/move" src="capitalize.mv"></script>` -> capitalize

- LispyScript http://lispyscript.com/docs/#browserrunning
  `<script type="text/lispyscript" id="square" src="./src/square.ls"></script>`
  `<script type="text/lispyscript" id="main">...`
  idでモジュール名決めるのかぁ。

- https://github.com/yhara/biwascheme/pull/18
  `<script id="biwa-script" ...`

- https://github.com/biwascheme/biwascheme/pull/27
  `<script class="biwascheme">...</script>`
  `<script class="biwascheme" src="...">`  この場合はtypeを書かないとJSと見なされるかな？

* モジュール定義
  - script type="text/biwascheme" data-library="a b c" とか書く感じか？

* autoload
  - BiwaScheme.autoload("/prefix/") とすると、以降のimportは
    (import (a b c)) -> GET /prefix/a/b/c.scm 
    みたいにAjax通信するようになる。とか？
    - importが直列化されるから遅そうだけどな
      - すごく頑張れば並列化できなくもないけど、トポロジカルソートが要りそう

## 2014/02/19

### パッチ読み 20:39

6645c1 (Modularity update) を読む。
とくにコンフリクトはない。

  1 * Got rid of global `p` and `put`.
  2 * Use Console.p and Console.put in place of globals
  3 * current_input and current_output defaults to Null ports
      so that users would define these interfaces.
  4 * removed default input/ouput ports in favor of null ports.
   (どういうこと？)
  5 * BrowserInput is now defined in the browser/console.js
  6 * Added an input/output implementation for the node platform.
  7 * Added CustomInput and CustomOutput ports for interfacing.
  8 * Fixed Node repl.
  9 * Implemented Node repl read.

- bin/biwas
  + resultがPauseになることあるんだろか。
    と思ったけど、(define (f) (p 1) (sleep 1) (p 2))みたいのが帰ってこない
    ことを想定してるのかな(WebのREPLのように)。じゃあそういうループを
    入れるべきかな？
    とりあえず今のままだと(sleep)のあとプロンプトが表示されない。
  - Port.current_outputをCustomInputにしている
    あとで見る。
+ repl.html
  + putsをcurrent_error/current_outputにしている。正しげ。
+ development_loader.js
+ header.js
  グローバルなpとputsを削除している。Console.pとConsole.putsに移動したみたい。
  BiwaScheme.Consoleじゃなくていいのか？
  nodeには漏れてない(がREPL上には漏れてる？) / ブラウザには漏れてる、という状態か。
  あー、なんでfunction(){}()で囲んでないか思い出した。developmentのときは
  単体ファイルで読みたいからか。
  release buildだけ囲むようにしたらいいのかなぁ。
+ extra_lib.js
+ srfi.js
+ webscheme_lib.js
+ browser/release_initializer.js
+ node/module_preamble.js
+ compiler.js
+ interpreter.js
+ website/js/biwascheme_terminal.js
  current_outputを定義している。CustomOutput(Console.puts)に設定している。

- port.js
  あとで
  + BrowserInputが消えてる
    => ブラウザのcurrent_outputに行ったっぽい？
  + DefaultOutputも消えてる
    => ブラウザ/nodeのcurrent_outputに行った
  - NullInput: get_stringがつねに空文字列を返す
    - これむしろEOFを返すべきか？
  + NullOutput:
    + output_functionを取るのはミスかな？
  + CustomOutput: 指定した関数をoutputにラップする
  - CustomInput: 指定した関数をinputにラップする？
    + get_stringがPause返すとどうなるんだろう
    + と思ったがBrowserInputがPause返してた模様
    - と思ったがafter呼ばないとだめなのでは
  + current_input/output/errorがNullInput/NullOutputになってる
    + 仕様変更か？と思ったが、browser/nodeで再定義してた
- browser/console.js
  + current_error, current_outputを定義
  - current_inputの実装が非自明
- node/module_postamble.js
  あとで

    
要修正：
- (sleep)のあとプロンプトが表示されない
-- ConsoleはBiwaScheme.Consoleにしたほうがベター
  (パッチ前から漏れてた模様)
-- NullOutputは引数をとらなくてよい

### ブランチ掃除 20:27

master> rmb -D mtornwall-reverse-empty-list
git branch -d -D mtornwall-reverse-empty-list
Deleted branch mtornwall-reverse-empty-list (was 3526ec0).
master> rmb -D mtornwall-hex-char-literals
git branch -d -D mtornwall-hex-char-literals
Deleted branch mtornwall-hex-char-literals (was dbf5cec).

## 2014/02/16

### 0.6.2リリース 21:46

+1. Edit History.txt
+2. Edit VERSION
3. Edit node_modules/biwascheme/package.json
  これ要らないのかな？？
+4. $ make -B
5. Make sure it is working:
   + run tests
     + open test/spec.html
     + open test/spec.html#release
     + open test/spec.html#min
     + run test/browser_functions/
       + $ cd test/browser_functions && node server.js && open http://localhost:7001/
   + run demos
     - demo/*
     - open website/i.html
     - open test/tracer.html
     - open test/tracer_auto.html
   + try npm package
       - $ npm install node_modules/biwascheme/ -g
       - $ biwas -v
6. Commit and create tag ($ git tag x.y.z)
7. Push changes to github with --tags
8. Update website on web server (git pull)
9. Publish npm package
  - $ npm publish node_modules/biwascheme/
10. Copy generated files (release/*.js, src/version.js) to web server
  - copy src/deps/underscore(.string).js, too


## 2014/02/15

* max_trace_size
  + BS.max_trace_sizeを追加
  + Interpreter#max_trace_sizeを追加
    (これも親intpから引き継ぐ必要があるなぁ)
  + テスト
    + max_trace_sizeが99のとき
    + max_trace_sizeが1のとき
    + max_trace_sizeが0のとき

### popに失敗するケース 22:12

のテストを書かなきゃ、と思ったんだが、どういうケースだっけ。
tco_counterはcapしないから関係ないよね。

capが0だとエラーになると思ったんだけどならないなぁ。

あ、トップレベルの(f)はtail call扱いになるのか。そうか。

...おっと、[].pop()ってエラーにならないのか(´・ω・`)

### そっか 22:09

tco_counterの方はstack frameの数しか積まない(= TCのときは積まない)から、capしなくていいのか。

### Stack frame 21:14

opecodes.mkdのtco_hinted_applyの項に説明を書いた。英語で書くの難しい。

要点：

 - call_stackは関数呼び出しごとに増えるが、スタックフレームはそうではない(TCのときは増えない)。そのためTC回数をカウントしておかないと、op_returnでcall_stackを何個popしたら良いかがわからない。

## 2014/02/13

### 単純にshiftしてよいか、という話 00:02

再掲。

```
通常：呼び出し時：
        op_frame
          フレームをthis.stackに積む
          tco_counterに0をpush
        op_apply
          this.call_stackに関数名をpush
      リターン時：
        op_return
          フレームをpop(sレジスタを変更)
          tco_counterをpop

TC  ：呼び出し時：
        (op_frameは呼ばれない。this.stackは操作しない)
        op_shift
          スタックから不要な引数を除去
        tco_hinted_apply
          this.tco_counterをインクリメントする
        op_apply
          this.call_stackに関数名をpush
      リターン時：
        op_return
          フレームをpop(sレジスタを変更)
          tco_counterをpop
```



### だいたい分かったかなぁ 23:10

GH #9に、call_stackが縮まないバグがあるかもと書かれてるけど、どういうケースだろう。良さそうに見えたんだけど。

intpをまたぐケースとかだとめんどいな。とりあえずリリースを優先しようかな。

### メモ 23:09

#### call_stack

- initialize: 初期化
- conti, nuate: call_stackも保存する
- execute: catch後にmessageにcall_stackを付加

- op_apply: this.call_stackにthis.last_referをpushする
- op_return: this.tco_counterを見て、必要な数だけpopする

#### tco_counter

tco_counterの長さは、スタックフレームの長さと一致する。
一方、applyの回数はスタックフレーム長とは一致しない
(TCの場合はスタックフレームを積まずにapplyするため)。
tco_counterは、この差分を保持している。

通常：呼び出し時：
        op_frame
          フレームをthis.stackに積む
          tco_counterに0をpush
        op_apply
          this.call_stackに関数名をpush
      リターン時：
        op_return
          フレームをpop(sレジスタを変更)
          tco_counterをpop

TC  ：呼び出し時：
        (this.stackは操作しない)
        op_shift
          スタックから不要な引数を除去
        tco_hinted_apply
          this.tco_counterをインクリメントする
        op_apply
          this.call_stackに関数名をpush
      リターン時：
        op_return
          フレームをpop(sレジスタを変更)
          tco_counterをpop

TCのとき：frameは積まないが、

- initialize: 初期化
- conti, nuate: 保存する

- op_frame:
    tco_counter.push(0)
- op_tco_hinted_apply: 
    tco_counterのlastをインクリメントする
- op_return:
    tco_counter.last + 1 だけ、call_stackをpopする
    その後、tco_counter自身をpopする

#### Interpreter#last_refer

- #save_stack: スタックオブジェクトが
  last_refer, call_stack, tco_counterをもってる
- #restore_stack: 上の3つを復元する
- refer-local, refer-free: 名前がとれないので"(anon)"
- refer-global: symが入る (symが偽のことないように見えるが？)
- constant: "(anon)"

- op_apply: this.call_stackにthis.last_referをpushする

#### tco_hinted_apply

関数呼び出しとcall/ccに、tco_hinted_applyが入る可能性がある。

たぶん
["shift", n, ["apply"]]が
["shift", n, ["tco_hinted_apply"]]になったんだろうな。

call/ccってどう関係あるんだっけ。

    (define (f)
      (call/cc (return)
        ...
        (when x (return)))
      (g))

じゃないや、なんだこれ。こうか。

    (define (f)
      (call/cc (lambda (return)
                  ...
                  (when x (return)))
                (g)))

call/cc自体が、一種の関数呼び出し...引数のlambdaを呼び出す...だからTCOが関係あるのね。把握した。

TCOならframeを積まない、というのはどこでやってるんだっけ。
と思ったがop_applyのここか。

>          return this.is_tail(next) ? c : ["frame", c, next];

### tco_counter 20:04

一応、どういう構造なのか把握しとくか。

### stack trace size 17:32

- BiwaScheme.max_trace_size = 40; (初期値)
- Interpreter#max_trace_size (インタプリタ毎の設定)

初期設定とかどこに書けばいいだろ。header.jsかなぁ。

うーんしかし、これ適当にpopすると、pop()がエラーになったりするよなぁ。
極端な話、max_trace_sizeが0でもちゃんと動くようにしないといけない。
単にlengthが0ならpopしない、で良いのかな？？

## 2014/02/12

### とりあえず試すしか無いか 21:26

と思ったけど、どのみちtrace sizeをキャップできる仕組みはあるといいものではある。

+ 末尾再帰なnamed letを書く
+ push時にスタックサイズを表示するようにする
  interpreter.js

  => 末尾再帰でも普通にどんどん伸びるな...

+ 末尾再帰でないnamed letで試す
  => 当然一緒である。

    (let loop ((x 1))
      (console-log x)
      (sleep 3)
      (loop (+ x 1))
      1)

ということで、BiwaScheme.max_traces = 40; みたいな形でconfigurableにしよう。

### うっ 21:08

named letで無限ループするケースで、スタックトレースが溢れる可能性が？

Interpreter#call_stackが配列らしい。これはinterpreter.js以外からは触ってない。

- _executeでJS例外が出たとき、e.messageにスタックトレースを追加して
  on_errorを呼ぶ
- "apply"時にcall_stackにpushしている
  "return"時にcall_stackをpopする

さてnamed letのときのIRってどうなるんだっけ...

      // (let loop ((a 1) (b 2)) body ..)
      //=> (letrec ((loop (lambda (a b) body ..))) (loop 1 2))

だそうで。

なんか末尾と末尾でない時で違いそうでめんどそう。

### Modularity Update 21:00

diff分けてほしみ...

  1 * Got rid of global `p` and `put`.
  2 * Use Console.p and Console.put in place of globals
  3 * current_input and current_output defaults to Null ports
      so that users would define these interfaces.
  4 * removed default input/ouput ports in favor of null ports.
   (どういうこと？)
  5 * BrowserInput is now defined in the browser/console.js
  6 * Added an input/output implementation for the node platform.
  7 * Added CustomInput and CustomOutput ports for interfacing.
  8 * Fixed Node repl.
  9 * Implemented Node repl read.

とりあえず0.6.2出してから見ようかなぁ。

### 0.6.2リリース 20:24

0.6.1のリリース、2011/12/01なんだがｗ

- ユーザに関係ある変更点
  - new: regexp-replace-all
  - new: vector-push! (= Array#push in JS)
  - new: Support hex character literals (eg. #\x41 => #\A)
  - new: Fix (reverse '())
- あまり関係ない変更点
  - add local_website.js
  - add doc/*.md
  - release/以下に過去バージョン(0.6.1だけだが)を追加
  - websiteを独自エンジンから変更
    結局どうしたんだっけ？
    * biwascheme/biwaschemeで、release/biwascheme-x.y.z.jsをコミット
    * biwascheme/biwascheme.github.ioでそれをマージし、release/biwascheme.jsとしてコピー
    ということらしい。
    そうか、いったんサイトがダウンしてたのか。
  - などなど

### inc!はこわれたのか 19:50

    return List(Sym("set!"),
                target, 
                List(Sym("+"), target, 1));

deep/shallowとは関係ないように見えるなぁ。Arrayを引数に使ってないので。

```
commit 9361a60af42851ff0a50c95660e0b440b011ac3a
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Thu Oct 25 00:47:56 2012 +0900

    fix: inc! and dec! was broken
```

ここで直したのか。そっちだけコミットしちゃったとかなのかな。

### あれ 19:44

ソースはset-square-x!を使ってるが、定義されるのはsquare-x-set!じゃね？？
inc!関係ないような...

```
commit 60aa9ec63d770ef7f6ef8c8b096513201abba8c3
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Sun Oct 7 05:43:23 2012 +0900

    record: default mutator name was wrong
```

このコミットで直してるが、raphaelisの方は触ってなさげ。

別のブランチで直したとかなのかなぁ？？

### inc! 19:35

inc!が壊れてる？というメモがあるけどどういう理由なんだっけ。

どういう原因でset-square-x!が見えなくなるんだったかな…。メモの意味が無いぞ。


(begin 
  ((lambda (__rtd) ((lambda (__cd) (_define-record-type (quote square) __rtd __cd)) (make-record-constructor-descriptor __rtd #f #f)))
   (make-record-type-descriptor (quote square) #f #f #f #f #((mutable x) (mutable y) (immutable rect))))
  (define make-square (record-constructor (_record-constructor-descriptor (quote square))))
  (define square? (record-predicate (_record-type-descriptor (quote square)))) (define square-x (record-accessor (_record-type-descriptor (quote square)) 0)) (define square-y (record-accessor (_record-type-descriptor (quote square)) 1)) (define square-rect (record-accessor (_record-type-descriptor (quote square)) 2)) (define square-x-set! (record-mutator (_record-type-descriptor (quote square)) 0)) (define square-y-set! (record-mutator (_record-type-descriptor (quote square)) 1)))

### Raphaelis 19:25

> Error: execute: unbound symbol: "set-square-x!" [block-new!, (anon), make-block, (anon), (anon), map, (anon), square-new!, (anon), (anon), square-move!] 

> 99e28ca8220b0c004ceb498a042dcc543d760fe6 Fixed shallow vs. deep list conversion.

このコミットが原因らしい。

## 2014/02/10

### Raphaelis 01:07

あれ？こいつ、動くぞ。

と思ったら../release/biwascheme.jsを見てるからか。

### と見せかけて 01:06

やらない。

### はー 22:47

やるか。

## 2013/12/01

### #19 11:23

loadのバグらしい。


## 2013/11/19

### 未push 20:34

```
commit 0165d8e175fc9e4b77f40311e789aa99afdd5a35
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Thu Jan 12 00:44:50 2012 +0900

    updated TODO

commit b17c76bf890d2b1797f55c544527146d30db0746
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Thu Jan 12 00:31:55 2012 +0900

    refactor: define short names locally in compiler.js

commit fc5e6a1a841faf2f06008fcae123db9b4eb5d758
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Wed Jan 11 16:46:41 2012 +0900

    new: BiwaScheme.DOT (use with BiwaScheme.List)

    Because I often want to specify the last cdr for List().
    eg.
      List(Sym("lambda"), bindings, DOT, body)
```

(追記：どれも捨ててもよさそうだったので、マージはしないことにした)

### Raphaelisのやつ 16:14

どうも未pushのコミットがあるみたい。

```
commit 0165d8e175fc9e4b77f40311e789aa99afdd5a35
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Thu Jan 12 00:44:50 2012 +0900

    updated TODO

commit b17c76bf890d2b1797f55c544527146d30db0746
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Thu Jan 12 00:31:55 2012 +0900

    refactor: define short names locally in compiler.js

commit fc5e6a1a841faf2f06008fcae123db9b4eb5d758
Author: Yutaka HARA <yutaka.hara.gmail.com>
Date:   Wed Jan 11 16:46:41 2012 +0900

    new: BiwaScheme.DOT (use with BiwaScheme.List)

    Because I often want to specify the last cdr for List().
    eg.
      List(Sym("lambda"), bindings, DOT, body)
```

この3つかな？

## 2013/11/17

### リリースなど 20:43

しました。(リリースじゃないけど)

とりあえずWebサイトが復活した、といえる状態になった。

## 2013/11/15

### リリース手順 18:43

* biwascheme/biwaschemeで、release/biwascheme-x.y.z.jsをコミット
* biwascheme/biwascheme.github.ioでそれをマージし、release/biwascheme.jsとしてコピー

という感じかな？

これで、なるべく開発環境とWebサイトが近い形になるかな。

### gitignore 17:46

.gitignoreにrelease/biwascheme.jsを入れていても、変更があるとgit stに出てしまうようだ。
まあそうか。

やりたいこと...
  Web用リポジトリのみ、release/biwascheme.jsが存在するようにしたい。

うん、これで結論でてるような…。

## 2013/11/10

### fork 01:04

現状

    yhara/biwascheme
      -- user1/biwascheme
      -- biwascheme/biwascheme
        -- user2/biwascheme

変更後？
   
    yhara/biwascheme
      -- user1/biwascheme

    biwascheme/biwascheme
        -- user2/biwascheme ??

### プレビュー(2) 13:52

あれ、リポジトリを分けても、wintersmithでプレビューできない件は解決しないのかも。
reposを./と、./source/contents/の両方に置かないといけないからなぁ。

いや、./source/contents/reposにgit cloneすればいいのか。

### release/ 13:50

リポジトリを分けるのであれば、メインリポジトリにリリースビルドをコミットしなくても良いのか。そうか。リリース時の作業が増えるけど、まあそんなにやるもんでもないんだよね…。

### プレビュー 13:46

プレビューはどうしようかなぁ。
そういえば現在でも、demo/以下ってdevelopment_loaderを呼んでるんだっけか。

* demo/はrelease/を見るようにする
  + 
  - release/をコミットすると、ビルドごとにgit statusが汚れて面倒
* gruntとか使う

てかコミット済みのパスって.gitignoreに指定できるんだっけ。できるならそれでも良いかも。

### Wintersmith 13:40

なんとかしてbiwascheme/biwaschemeとbiwascheme/biwascheme.github.ioを1リポジトリにまとめられないかと思ったが、うまく行かず。リポジトリを分けた方が楽そう。

サイトジェネレータ使うならgh-pagesにpushするコマンドがあるromulusの方が良いのでは、と思ったが、Orgのトップページなのでgh-pagesじゃなくてmasterなのだった。

ということで、

* リリース時、メインリポジトリのrelease/以下にビルド済みのものをコミットする
* repos以下でgit co vx.x.x
* サイト更新は、wintersmith build -o . で

ということにしようと思う。

## 2013/11/04

### DLリンクの復旧 19:51

とりあえずrepos以下を(submoduleじゃなくて)ハードコミットした。タグは0.6.1。

submoduleの消し方をミスったけど、どうせあとでbiwascheme/biwaschemeに一本化するつもりなので、とりあえず置いておく。


###  19:50

やれることから一つずつやっていく。
