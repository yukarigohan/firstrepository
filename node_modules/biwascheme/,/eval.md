# eval, load

## load: やること

- (load xxx) は、cwdをベースにする(/から始まらないとき)
  - TODO: windowsのNodeってどうなるのかしら
- (set-load-path! path) : ロードパスを設定
- (load-path) 

## 2017/06/26

### log 01:38

  - (load "foo.scm")のサーチパスがおかしい
    - どうあるべき？
      - Nodeみたいにそのファイルからの相対パスにできないか
        - load中にloadした場合は？

## 2017/06/24

### そうか 19:19

クロージャに入れてスタックに積めばよさそうな気がしてきた。なるほどな〜。

### コンテキストはいつ切り替わるか 09:26

実は、関数呼び出しのタイミングでしか切り替わらない？
クロージャオブジェクトがpathを持てばよい？
あ、あとcontinuationオブジェクトか。

## 2017/06/23

### てか 22:13

とりあえず絶対パスくらいは通るようにしてリリースすべきだったなぁ。

### relative以外の仕様 21:44

- a) カレントディレクトリから読む
  - この場合、pwdをとるAPIが必要
- b) LOAD_PATH的なものを定義

### load 21:40

いろいろ考えたけど、中間言語に手を入れるしかない気がする。
極端な例として、2つのファイルで作ったクロージャーが交互に関数に渡るとか。

b1/b1.scm:
  (call-a (lambda () (load "c.scm")))  ; b1/c.scm

b2/b2.scm:
  (call-a (lambda () (load "c.scm")))  ; b2/c.scm

## 2017/06/18

### 何がやりたいのか 21:27

loadのセマンティクスをレキシカルにしたい。

## 2017/06/17

###  18:56

(load "foo.scm") がどこで呼ばれたか
それを実行しているintp
  が今何をしているかは分からない

### どうすればよいか 18:38

node/module_postamble.js にloadがある

    BiwaScheme.define_libfunc("load", 1, 1, function(ar) {
      var relpath = ar[0];
      BiwaScheme.assert_string(relpath);
      // assume path is relative to node_modules directory
      var filename = __dirname + "/../../../" + relpath;
      var code = require("fs").readFileSync(filename, "utf8");
      return BiwaScheme.run(code);
    });

いまは環境が一つしか無いのでBiwaScheme.runを使っている。
runは新しいintpでevaluateする

  - main(a.scm):
    - load "lib/b.scm":
      - load "c.scm":

intpに持たせるだけではだめな気がする
古いコードがループしてる場合とかあるしな。

### load中load 18:31

a.scm:
  (load "lib/b.scm")

lib/b.scm:
  (load "c.scm")   ;=> lib/c.scmを読んでほしい

つまりRubyのrequire_relative相当にする。
(ちゃんとしたい場合はimportを)


