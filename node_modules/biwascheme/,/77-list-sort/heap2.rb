def heap_sort!(ary, comp)
  return if ary.length <= 1
  # 子をもつノードを後ろから順にdownheapする
  #t = (ary.length-2)/2
  #loop do
  #  break if t < 0
  #  downheap!(ary, t, ary.length-1, comp)
  #  t -= 1
  #end
  downheap!(ary, comp, (ary.length-2)/2, ary.length-1, 1)

#  # 末尾から順に、先頭の要素(＝最大)と入れ替えを行い、残りをヒープにする
#  # state 3
#  t = ary.length-1
#  loop do
#    break if t == 0
#    ary[0], ary[t] = ary[t], ary[0]
#    downheap!(ary, comp, 0, t-1)
#    t -= 1
#  end
end

def downheap!(ary, comp, k, r, s)
  # kが起点なので、kの値を覚えておく
  # state 1, 4
  i = k
  v = ary[k]
  loop do
    j = 2*i+1  # iの左の子を見る
    break if j > r  # 左の子がなければ完了
    if j != r  # 左の子が最終でない(=右にも子がある)とき
      j+=1 if comp.call(ary[j], ary[j+1]) # 左右の子を比較し、大きい方を覚える
    end
    break if comp.call(ary[j], v) # kが最大なら終了
    ary[i] = ary[j]  # 子の方が大きいときは、入れ替えを行い、
    i = j          # さらにその子に対して作業を続ける
  end
  # state 2
  ary[i] = v

  if s == 1
    if k > 0
      return downheap!(ary, comp, k-1, ary.length-1, 1)
    else
      t = ary.length-1
    end
  else
    t = r
    return if t == 0
  end
  ary[0], ary[t] = ary[t], ary[0]
  downheap!(ary, comp, 0, t-1, 2)
end

#a = [2143,43,7798,98,98,67,2,34543,2].map.with_index{|_, i| i}
#heap_sort!(a, lambda{|x, y| print '.'; x < y})
#p a
10000.times do
  ary = Array.new(rand(10)){ rand(12345).to_s }
  # 安定なソートを行う
  sorted = ary.map.with_index{|v, i| [v, i]}.sort_by{|v, i| [v, i]}.map{|v, i| v}
  heap_sort!(ary, lambda{|x, y| x < y})
  if ary.map(&:object_id) != sorted.map(&:object_id)
    p ary: ary
    p sorted: sorted
  else
    print "."
  end
end
p :ok

