def heap_sort!(ary, comp)
  # state 0
  # 子をもつノードを後ろから順にdownheapする
  ((ary.length-2)/2).downto(0) do |t|
    downheap!(ary, t, ary.length-1, comp)
  end

  # 末尾から順に、先頭の要素(＝最大)と入れ替えを行い、残りをヒープにする
  # state 3
  (ary.length-1).downto(1) do |t|
    ary[0], ary[t] = ary[t], ary[0]
    downheap!(ary, 0, t-1, comp)
  end
end

def downheap!(ary, k, r, comp)
  # kが起点なので、kの値を覚えておく
  # state 1, 4
  i = k
  v = ary[k]
  loop do
    j = 2*i+1  # iの左の子を見る
    break if j > r  # 左の子がなければ完了
    if j != r  # 左の子が最終でない(=右にも子がある)とき
      j+=1 if comp.call(ary[j], ary[j+1]) # 左右の子を比較し、大きい方を覚える
    end
    break if comp.call(ary[j], v) # kが最大なら終了
    ary[i] = ary[j]  # 子の方が大きいときは、入れ替えを行い、
    i = j          # さらにその子に対して作業を続ける
  end
  # state 2
  ary[i] = v
end

#a = [2143,43,7798,98,98,67,2,34543,2].map.with_index{|_, i| i}
#heap_sort!(a, lambda{|x, y| print '.'; x < y})
#p a
10000.times do
  ary = Array.new(rand(10)){ rand(12345).to_s }
  # 安定なソートを行う
  sorted = ary.map.with_index{|v, i| [v, i]}.sort_by{|v, i| [v, i]}.map{|v, i| v}
  heap_sort!(ary, lambda{|x, y| x < y})
  if ary.map(&:object_id) != sorted.map(&:object_id)
    p ary: ary
    p sorted: sorted
  else
    print "."
  end
end
p :ok
