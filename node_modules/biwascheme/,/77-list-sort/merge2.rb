require_relative 'check.rb'
# 再帰をループにしたバージョン

def merge(ary1, ary2, comp, ret, i, j, k)
  len1, len2 = ary1.length, ary2.length
  #ret = Array.new(len1 + len2)
  #i, j, k = 0, 0, 0
  if i < len1 && j < len2
    return comp.call(ary2[j], ary1[i], lambda{|lt|
      if lt
        ret[k] = ary2[j]; k+=1; j+=1
      else
        ret[k] = ary1[i]; k+=1; i+=1
      end
      merge(ary1, ary2, comp, ret, i, j, k)
    })
  end
  while i < len1
    ret[k] = ary1[i]; k+=1; i+=1
  end
  while j < len2
    ret[k] = ary2[j]; k+=1; j+=1
  end
  return ret
end

# route = [0, 1] みたいな

def merge_sort(ary, comp)
  # 最初のブロックのrouteを求める
  l = ary.length
  route = []
  while l >= 2
    l /= 2
    route << 0
  end

  loop do
    start, len = 0, ary.length
    route.each do |lr|
      len /= 2
      start += len if lr == 1
    end

    if len >= 1
      route += [0]
      next
    else
      if route[-1] == 0
        route[-1] = 1
        next
      else
        merge(ary1, ary2, comp, Array.new(ary1.length+ary2.length), 0, 0, 0) do
        end
      end
    end



#  if ary.length <= 1
#    return ary
#  else
#    # リストを半分にし、それぞれをソートされた状態にする
#    len1 = ary.length / 2
#    len2 = ary.length - len1
#    ary1, ary2 = merge_sort(ary[0, len1], comp),
#               merge_sort(ary[len1, len2], comp)
#
#    # マージを行う
#    return merge(ary1, ary2, comp)
#  end
end

#p merge_sort(["1a", "1b", "1c"], lambda{|a, b| a[0] < b[0]})

check do |ary|
  merge_sort(ary, lambda{|a, b, cont| cont.call(a < b)})
end
